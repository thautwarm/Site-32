<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
        <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Write You A Query Language &#8212; thautwarm&#39;s blog pages</title>
    <link rel="stylesheet" href="../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Fiction" href="../Fiction/index.html" />
    <link rel="prev" title="DSL" href="index.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../_static/js/jquery-1.11.0.min.js "></script>
<script type="text/javascript" src="../_static/js/jquery-fix.js "></script>
<script type="text/javascript" src="../_static/bootstrap-3.3.7/js/bootstrap.min.js "></script>
<script type="text/javascript" src="../_static/bootstrap-sphinx.js "></script>

  </head><body>

  <div id="navbar" class="navbar navbar-inverse navbar-default ">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../guide.html">
          Site-32</a>
        <span class="navbar-text navbar-version pull-left"><b></b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="https://github.com/thautwarm">GitHub</a></li>
                <li><a href="../PL/index.html">PL</a></li>
                <li><a href="../Design/index.html">Design</a></li>
                <li><a href="index.html">DSL</a></li>
                <li><a href="../Fiction/index.html">Fiction</a></li>
                <li><a href="../Others/index.html">Others</a></li>
                <li><a href="../Backup/index.html">Backup</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../guide.html">Site-32 <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../index.html">Site-32 Considered Harmful</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Compiler/index.html">Compiler</a><ul class="simple">
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../Design/index.html">Design</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../Design/General-Programming-In-Julia-Language-From-An-Advanced-Standpoint.html">General Programming In Julia Language From An Advanced Standpoint</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../Design/General-Programming-In-Julia-Language-From-An-Advanced-Standpoint.html#first-class">First-Class</a></li>
<li class="toctree-l3"><a class="reference internal" href="../Design/General-Programming-In-Julia-Language-From-An-Advanced-Standpoint.html#polymorphisms-of-multiple-dispatch">Polymorphisms of Multiple Dispatch</a></li>
<li class="toctree-l3"><a class="reference internal" href="../Design/General-Programming-In-Julia-Language-From-An-Advanced-Standpoint.html#full-featured-macros">Full-Featured Macros</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../Design/General-Programming-In-Julia-Language-From-An-Advanced-Standpoint.html#macro-the-function-from-ast-to-ast">Macro, the Function from AST to AST</a></li>
<li class="toctree-l4"><a class="reference internal" href="../Design/General-Programming-In-Julia-Language-From-An-Advanced-Standpoint.html#scope-and-hygiene">Scope and Hygiene</a></li>
<li class="toctree-l4"><a class="reference internal" href="../Design/General-Programming-In-Julia-Language-From-An-Advanced-Standpoint.html#other-useful-knowledge-for-julia-macros">Other Useful Knowledge for Julia Macros</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../Design/General-Programming-In-Julia-Language-From-An-Advanced-Standpoint.html#a-big-step-forward-in-ast-manipulations">A Big Step Forward in AST Manipulations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../Design/General-Programming-In-Julia-Language-From-An-Advanced-Standpoint.html#limitation-absence-of-function-types">Limitation: Absence of Function Types</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../Design/Some-Thoughts-About-The-RestrainJIT.html">Some Thoughts About The Restrain JIT</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Design/Research-Restrain-JIT.html">Research: Review and Observations of Python JIT</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../Design/Research-Restrain-JIT.html#history">History</a></li>
<li class="toctree-l3"><a class="reference internal" href="../Design/Research-Restrain-JIT.html#observations">Observations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../Design/PEP622-1.html">My Comments about PEP 622(V1)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../Design/PEP622-1.html#my-concerns">My Concerns</a></li>
<li class="toctree-l3"><a class="reference internal" href="../Design/PEP622-1.html#scoping-issues">Scoping Issues</a></li>
<li class="toctree-l3"><a class="reference internal" href="../Design/PEP622-1.html#comments-about-the-rejection-of-and-patterns">Comments about the rejection of AND (&amp;) patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="../Design/PEP622-1.html#consider-performance-guards-as-patterns">Consider Performance: Guards As Patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="../Design/PEP622-1.html#grammar-change-feature-request-parameterized-patterns">Grammar Change &amp; Feature Request: Parameterized Patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="../Design/PEP622-1.html#an-alternative-match-protocol-can-be-better-in-simplicity-efficiency-and-expressivity">An Alternative <code class="docutils literal notranslate"><span class="pre">__match__</span></code> Protocol Can be Better in Simplicity, Efficiency, and Expressivity.</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../Design/PEP622-1.html#simplicity-of-the-alternative-match-protocol">Simplicity of the alternative <code class="docutils literal notranslate"><span class="pre">__match__</span></code> protocol</a></li>
<li class="toctree-l4"><a class="reference internal" href="../Design/PEP622-1.html#the-alternative-match-protocol-is-efficient">The alternative <code class="docutils literal notranslate"><span class="pre">__match__</span></code> protocol is efficient</a></li>
<li class="toctree-l4"><a class="reference internal" href="../Design/PEP622-1.html#the-alternative-match-protocol-results-in-better-expressivity">The alternative <code class="docutils literal notranslate"><span class="pre">__match__</span></code> protocol results in better expressivity</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../Design/PEP622-1.html#miscellaneous">Miscellaneous</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../Design/PEP622-1.html#else-clauses-in-pattern-matching"><code class="docutils literal notranslate"><span class="pre">else</span></code> Clauses in Pattern Matching</a></li>
<li class="toctree-l4"><a class="reference internal" href="../Design/PEP622-1.html#grammar-of-patterns-could-become-that-of-expressions">Grammar of Patterns Could Become That of Expressions</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../Design/PEP622-2.html">PEP 622(V2)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../Design/PEP622-2.html#bringing-else-back-is-rejected">Bringing <code class="docutils literal notranslate"><span class="pre">else</span></code> Back is Rejected</a></li>
<li class="toctree-l3"><a class="reference internal" href="../Design/PEP622-2.html#variables-in-patterns-bindings-instead-of-evaluations-and-comparisons">Variables in Patterns: Bindings instead of Evaluations and Comparisons</a></li>
<li class="toctree-l3"><a class="reference internal" href="../Design/PEP622-2.html#alternative-match-protocol">Alternative <code class="docutils literal notranslate"><span class="pre">__match__</span></code> Protocol</a></li>
<li class="toctree-l3"><a class="reference internal" href="../Design/PEP622-2.html#the-switch-semantics">The Switch Semantics</a></li>
<li class="toctree-l3"><a class="reference internal" href="../Design/PEP622-2.html#scope">Scope</a></li>
<li class="toctree-l3"><a class="reference internal" href="../Design/PEP622-2.html#miscellaneous">Miscellaneous</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">DSL</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Write You A Query Language</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#definition-of-syntaxes">Definition of Syntaxes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#codegen-target">Codegen Target</a></li>
<li class="toctree-l3"><a class="reference internal" href="#refinement-of-codegen-typed-columns">Refinement of Codegen: Typed Columns</a></li>
<li class="toctree-l3"><a class="reference internal" href="#implementation">Implementation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#enjoy-you-a-query-language">Enjoy You A Query Language</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../Fiction/index.html">Fiction</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../Fiction/index.html#id1">2021年4月</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Fiction/index.html#id3">2020年10月</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Fiction/index.html#id4">2020年6月</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Fiction/index.html#id7">2020年4月</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Fiction/index.html#id9">2019年10月</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../Fiction/index.html#id10">日前安排</a></li>
<li class="toctree-l3"><a class="reference internal" href="../Fiction/index.html#id18">目录</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../Fiction/日记2019-10-13.html">Smarter Witnesses for Type Classes</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../Fiction/日记2019-10-13.html#notation">Notation</a></li>
<li class="toctree-l5"><a class="reference internal" href="../Fiction/日记2019-10-13.html#instance-resolution-variables-as-instances">Instance Resolution &amp; Variables As Instances</a></li>
<li class="toctree-l5"><a class="reference internal" href="../Fiction/日记2019-10-13.html#the-most-general-instance-problem-overlapping-instance-problem">“The Most General Instance” Problem &amp; “Overlapping Instance” Problem</a></li>
<li class="toctree-l5"><a class="reference internal" href="../Fiction/日记2019-10-13.html#id1">优化</a></li>
<li class="toctree-l5"><a class="reference internal" href="../Fiction/日记2019-10-13.html#id2">该算法和相应语言设计的好处</a></li>
<li class="toctree-l5"><a class="reference internal" href="../Fiction/日记2019-10-13.html#id3">不足之处</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../Fiction/日记2019-10-15.html">我和Python的故事</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../Fiction/日记2019-10-15.html#id1">第0节</a></li>
<li class="toctree-l5"><a class="reference internal" href="../Fiction/日记2019-10-15.html#id2">第1节: 科学计算, Python, 生物信息学和数据挖掘</a></li>
<li class="toctree-l5"><a class="reference internal" href="../Fiction/日记2019-10-15.html#id3">第2节: 转型的经过, 走向程序语言设计领域</a></li>
<li class="toctree-l5"><a class="reference internal" href="../Fiction/日记2019-10-15.html#id4">第3节: 想要给Python添加高级语言特性的理想</a></li>
<li class="toctree-l5"><a class="reference internal" href="../Fiction/日记2019-10-15.html#id5">第4节: Flowpython</a></li>
<li class="toctree-l5"><a class="reference internal" href="../Fiction/日记2019-10-15.html#bnf-parser-generator">第4节: BNF, Parser Generator和语言制造机器</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../Fiction/日记2019-10-30.html">杂谈</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../Fiction/日记2019-10-30.html#pycon-china-2019">PyCon China 2019 成都</a></li>
<li class="toctree-l5"><a class="reference internal" href="../Fiction/日记2019-10-30.html#id2">直面自己的人格缺陷</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../Fiction/日记2019-11-06.html">杂谈</a></li>
<li class="toctree-l4"><a class="reference internal" href="../Fiction/日记2019-11-14.html">我太难了</a></li>
<li class="toctree-l4"><a class="reference internal" href="../Fiction/日记2019-11-17.html">我太懂了</a></li>
<li class="toctree-l4"><a class="reference internal" href="../Fiction/日记2020-01-07.html">打通</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../Fiction/日记2020-01-07.html#parsing">Parsing</a></li>
<li class="toctree-l5"><a class="reference internal" href="../Fiction/日记2020-01-07.html#python">Python 字节码</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../Fiction/日记2020-02-02.html">Tagless Final in F#</a></li>
<li class="toctree-l4"><a class="reference internal" href="../Fiction/日记2020-02-07.html">Encoding Typeclass Default Methods in Purescript</a></li>
<li class="toctree-l4"><a class="reference internal" href="../Fiction/日记2020-02-11.html">近期规划</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../Fiction/日记2020-02-11.html#purescript-python">Purescript-Python</a><ul>
<li class="toctree-l6"><a class="reference internal" href="../Fiction/日记2020-02-11.html#anf">从表达式优先到语句优先: ANF变换</a></li>
<li class="toctree-l6"><a class="reference internal" href="../Fiction/日记2020-02-11.html#pythonfirst-class">Python虚拟机上的First-class的表达式优先</a></li>
<li class="toctree-l6"><a class="reference internal" href="../Fiction/日记2020-02-11.html#id2">社区意见</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../Fiction/cure/和平日久.html">如何写出令人感到幸福的小说</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../Fiction/cure/和平日久.html#id2">合理利用“无敌”元素</a></li>
<li class="toctree-l5"><a class="reference internal" href="../Fiction/cure/和平日久.html#id3">“纯爱”而非“后宫”</a></li>
<li class="toctree-l5"><a class="reference internal" href="../Fiction/cure/和平日久.html#id4">细腻的画面感</a></li>
<li class="toctree-l5"><a class="reference internal" href="../Fiction/cure/和平日久.html#id5">节奏流畅的回忆</a></li>
<li class="toctree-l5"><a class="reference internal" href="../Fiction/cure/和平日久.html#id6">暗线和潜台词</a></li>
<li class="toctree-l5"><a class="reference internal" href="../Fiction/cure/和平日久.html#id7">总结</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../Fiction/cure/乐理菜鸡怎么给自己的小说写bgm.html">乐理菜鸡怎么给自己的小说写BGM?</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../Fiction/cure/乐理菜鸡怎么给自己的小说写bgm.html#id1">找调</a></li>
<li class="toctree-l5"><a class="reference internal" href="../Fiction/cure/乐理菜鸡怎么给自己的小说写bgm.html#id2">打谱</a></li>
<li class="toctree-l5"><a class="reference internal" href="../Fiction/cure/乐理菜鸡怎么给自己的小说写bgm.html#id3">总结</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../PL/index.html">Programming Language</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../PL/HKT.html">Higher Kinded Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../PL/typeclass.html">Type Classes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../PL/typeclass.html#about-abstractions">About Abstractions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../PL/typeclass.html#about-separation-of-type-definitions-and-data-manipulations">About Separation of Type Definitions and Data Manipulations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../PL/paper-reading-LHKP.html">Paper Reading: Lightweight-Higher-Kinded-Polymorphism</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../PL/paper-reading-LHKP.html#how-to">How-To</a></li>
<li class="toctree-l3"><a class="reference internal" href="../PL/paper-reading-LHKP.html#static-resolution-more-polymorphic">Static Resolution: More polymorphic</a></li>
<li class="toctree-l3"><a class="reference internal" href="../PL/paper-reading-LHKP.html#limitation1-much-higher-kinded">Limitation1: Much Higher Kinded</a></li>
<li class="toctree-l3"><a class="reference internal" href="../PL/paper-reading-LHKP.html#limitation2-identity">Limitation2: Identity</a></li>
<li class="toctree-l3"><a class="reference internal" href="../PL/paper-reading-LHKP.html#why-this-lightweight-higher-polymorphism-instead-of-the-haskell-approach">Why this Lightweight-Higher-Polymorphism instead of the Haskell approach</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../PL/HKT-typeclass-FSharp.html">Compelling Higher Kinded Types and Type Classes in F#</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../PL/HKT-typeclass-FSharp.html#active-pattern">Active Pattern</a></li>
<li class="toctree-l3"><a class="reference internal" href="../PL/HKT-typeclass-FSharp.html#statically-resolved-type-parameters">Statically Resolved Type Parameters</a></li>
<li class="toctree-l3"><a class="reference internal" href="../PL/HKT-typeclass-FSharp.html#the-getsig-function-and-implicits">The <em>getsig</em> Function and Implicits</a></li>
<li class="toctree-l3"><a class="reference internal" href="../PL/HKT-typeclass-FSharp.html#why-abstractclass">Why AbstractClass?</a></li>
<li class="toctree-l3"><a class="reference internal" href="../PL/HKT-typeclass-FSharp.html#why-functor-f-instead-of-the-straightforward-functor">Why <em>Functor&lt;’F&gt;</em> instead of the straightforward <em>Functor</em></a></li>
<li class="toctree-l3"><a class="reference internal" href="../PL/HKT-typeclass-FSharp.html#references-and-further-reading">References and Further Reading</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../PL/plfp-20191212.html">FSYM: An Abstraction On Tagless-Final Style To Compositing And Decoupling Multiple Interpretations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../PL/plfp-20191212.html#terminology">Terminology</a></li>
<li class="toctree-l3"><a class="reference internal" href="../PL/plfp-20191212.html#background">Background</a></li>
<li class="toctree-l3"><a class="reference internal" href="../PL/plfp-20191212.html#introduction">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../PL/plfp-20191212.html#application">Application</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../PL/plfp-20191212.html#scoping-name-resolution">Scoping: Name Resolution</a></li>
<li class="toctree-l4"><a class="reference internal" href="../PL/plfp-20191212.html#typing-type-inference">Typing: Type Inference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../PL/plfp-20191212.html#references">References</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../PL/plfp-20191219.html">Tagless Final For Writing Compilers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../PL/plfp-20191219.html#problem">Problem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../PL/plfp-20191219.html#tagless-final-for-compiler-phases">Tagless Final For Compiler Phases</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../PL/plfp-20191219.html#quick-start-for-tagless-final">Quick Start for Tagless Final</a></li>
<li class="toctree-l4"><a class="reference internal" href="../PL/plfp-20191219.html#grammar">“Grammar”</a></li>
<li class="toctree-l4"><a class="reference internal" href="../PL/plfp-20191219.html#expanding-representation">Expanding Representation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../PL/plfp-20191219.html#problems-of-decoupling-and-compositing">Problems of Decoupling and Compositing</a></li>
<li class="toctree-l4"><a class="reference internal" href="../PL/plfp-20191219.html#fsym">FSYM</a></li>
<li class="toctree-l4"><a class="reference internal" href="../PL/plfp-20191219.html#laziness-for-mutual-dependencies">Laziness, for Mutual Dependencies</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../PL/plfp-20191219.html#example">Example</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../PL/elaborating-julia.html">Julia Counts for PL Researchers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../PL/elaborating-julia.html#expressiveness">Expressiveness</a></li>
<li class="toctree-l3"><a class="reference internal" href="../PL/elaborating-julia.html#staging">Staging</a></li>
<li class="toctree-l3"><a class="reference internal" href="../PL/elaborating-julia.html#advantages-as-a-codegen-backend">Advantages as a codegen backend</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../PL/tagless-final-pattern-match.html">First-class Pattern Matching in the Final Approach</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../PL/tagless-final-pattern-match.html#core-ideas">Core Ideas</a></li>
<li class="toctree-l3"><a class="reference internal" href="../PL/tagless-final-pattern-match.html#full-implementation-in-haskell">Full implementation in Haskell</a></li>
<li class="toctree-l3"><a class="reference internal" href="../PL/tagless-final-pattern-match.html#enhancement-1">Enhancement 1</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../PL/tagless-final-for-julia.html">Julia Benefits from Tagless Final</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../PL/tagless-final-for-julia.html#what-happened-today">What Happened Today?</a></li>
<li class="toctree-l3"><a class="reference internal" href="../PL/tagless-final-for-julia.html#an-example-turns-out-to-be-type-unstable">An Example Turns Out to be Type Unstable</a></li>
<li class="toctree-l3"><a class="reference internal" href="../PL/tagless-final-for-julia.html#tagless-final-encoding-about-above-code">Tagless Final Encoding about Above Code</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../PL/hrt-use-case.html">Some Use Cases for Higher Rank Polymorphisms(No Monad)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../PL/hrt-use-case.html#polymorphic-functions-for-edsl">Polymorphic Functions for eDSL</a></li>
<li class="toctree-l3"><a class="reference internal" href="../PL/hrt-use-case.html#existential-types">Existential Types</a></li>
<li class="toctree-l3"><a class="reference internal" href="../PL/hrt-use-case.html#manipulation-for-heterogeneous-data">Manipulation for Heterogeneous Data</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../Backup/index.html">Backup</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../Backup/高观点下的Julia泛用编程.html">高观点下的Julia泛用编程</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../Others/index.html">Others</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../Others/contributions.html">Thautwarm’s Open Source Contributions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../Others/contributions.html#projects-owned-by-other-individuals-organizations">Projects Owned By Other Individuals/Organizations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../Others/contributions.html#leading-projects">Leading Projects</a></li>
<li class="toctree-l3"><a class="reference internal" href="../Others/contributions.html#other-notable-personal-projects">Other Notable Personal Projects</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Subsections <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">Write You A Query Language</a><ul>
<li><a class="reference internal" href="#definition-of-syntaxes">Definition of Syntaxes</a></li>
<li><a class="reference internal" href="#codegen-target">Codegen Target</a></li>
<li><a class="reference internal" href="#refinement-of-codegen-typed-columns">Refinement of Codegen: Typed Columns</a></li>
<li><a class="reference internal" href="#implementation">Implementation</a></li>
<li><a class="reference internal" href="#enjoy-you-a-query-language">Enjoy You A Query Language</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <div class="section" id="write-you-a-query-language">
<h1>Write You A Query Language<a class="headerlink" href="#write-you-a-query-language" title="Permalink to this headline">¶</a></h1>
<p>You may have heard of LINQ or extension methods before, and they’re all
embedded query langauges.</p>
<p>In terms of Julia ecosystem, there’re already Query.jl, LightQuery.jl,
DataFramesMeta.jl, etc., each of which reaches the partial or full
features of a query language.</p>
<p>This document is provided for you to create a concise and efficient
implementation of query language, which is a way for me to exhibit the
power of MLStyle.jl on AST manipulations. Additionally, I think this
tutorial can be also extremely helpful to those who’re developing query
languages for Julia.</p>
<div class="section" id="definition-of-syntaxes">
<h2>Definition of Syntaxes<a class="headerlink" href="#definition-of-syntaxes" title="Permalink to this headline">¶</a></h2>
<p>Firstly, we can refer to the the T-SQL syntax and, introduce it into
Julia.</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">df</span> <span class="o">|&gt;</span>
<span class="nd">@select</span> <span class="n">selectors</span><span class="o">...</span><span class="p">,</span>
<span class="nd">@where</span> <span class="n">predicates</span><span class="o">...</span><span class="p">,</span>
<span class="nd">@groupby</span> <span class="n">mappings</span><span class="o">...</span><span class="p">,</span>
<span class="nd">@orderby</span> <span class="n">mappings</span><span class="o">...</span><span class="p">,</span>
<span class="nd">@having</span> <span class="n">mappings</span><span class="o">...</span><span class="p">,</span>
<span class="nd">@limit</span> <span class="n">JuliaExpr</span>
</pre></div>
</div>
<p>A <code class="docutils literal notranslate"><span class="pre">selector</span></code> could be one of the following cases.</p>
<ol class="arabic">
<li><p class="first">select the field <code class="docutils literal notranslate"><span class="pre">x</span></code> / select the 1-fst field</p>
<p><code class="docutils literal notranslate"><span class="pre">_.x</span> <span class="pre">/</span> <span class="pre">_.(1)</span></code></p>
</li>
<li><p class="first">select the field <code class="docutils literal notranslate"><span class="pre">x</span></code>(to support field name that’re not an
identifier)</p>
<p><code class="docutils literal notranslate"><span class="pre">_.&quot;x&quot;</span></code></p>
</li>
<li><p class="first">select an expression binded as <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">_.x</span></code>, where <code class="docutils literal notranslate"><span class="pre">x</span></code> is from
current scope</p>
<p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">_.x</span></code></p>
</li>
<li><p class="first">select something and bind it to symbol <code class="docutils literal notranslate"><span class="pre">a</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">&lt;selector</span> <span class="pre">1-3&gt;</span> <span class="pre">=&gt;</span> <span class="pre">a</span> <span class="pre">/</span> <span class="pre">&lt;selector</span> <span class="pre">1-3&gt;</span> <span class="pre">=&gt;</span> <span class="pre">&quot;a&quot;</span></code></p>
</li>
<li><p class="first">select any field <code class="docutils literal notranslate"><span class="pre">col</span></code> that
<code class="docutils literal notranslate"><span class="pre">predicate1(col,</span> <span class="pre">args1...)</span> <span class="pre">&amp;&amp;</span> <span class="pre">!predicate2(col,</span> <span class="pre">args2...)</span> <span class="pre">&amp;&amp;</span> <span class="pre">...</span></code> is
true</p>
<p><code class="docutils literal notranslate"><span class="pre">_.(predicate1(args...),</span> <span class="pre">!predicate2(args2...,</span> <span class="pre">),</span>&#160;&#160; <span class="pre">...)</span></code></p>
</li>
</ol>
<p>With E-BNF notation, we can formalize the synax,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FieldPredicate</span> <span class="p">::</span><span class="o">=</span> <span class="p">[</span><span class="s1">&#39;!&#39;</span><span class="p">]</span> <span class="n">QueryExpr</span> <span class="s1">&#39;(&#39;</span> <span class="n">QueryExprList</span> <span class="s1">&#39;)&#39;</span> <span class="p">[</span><span class="s1">&#39;,&#39;</span> <span class="n">FieldPredicate</span><span class="p">]</span>

<span class="n">Field</span>          <span class="p">::</span><span class="o">=</span> <span class="p">(</span><span class="n">Symbol</span> <span class="o">|</span> <span class="n">String</span> <span class="o">|</span> <span class="n">Int</span><span class="p">)</span>


<span class="n">QueryExpr</span>      <span class="p">::</span><span class="o">=</span>  <span class="s1">&#39;_&#39;</span> <span class="s1">&#39;.&#39;</span> <span class="n">Field</span>
                  <span class="o">|</span> <span class="o">&lt;</span><span class="n">substitute</span> <span class="n">QueryExpr</span> <span class="ow">in</span> <span class="k">for</span> <span class="n">JuliaExpr</span><span class="o">&gt;</span>

<span class="n">QueryExprList</span>  <span class="p">::</span><span class="o">=</span> <span class="p">[</span> <span class="n">QueryExpr</span> <span class="p">(</span><span class="s1">&#39;,&#39;</span> <span class="n">QueryExpr</span><span class="p">)</span><span class="o">*</span> <span class="p">]</span>

<span class="n">selector</span>       <span class="p">::</span><span class="o">=</span> <span class="s1">&#39;_&#39;</span> <span class="s1">&#39;.&#39;</span> <span class="n">FieldPredicate</span>
                  <span class="o">|</span> <span class="n">QueryExpr</span>
</pre></div>
</div>
<p>A <code class="docutils literal notranslate"><span class="pre">predicate</span></code> is a <code class="docutils literal notranslate"><span class="pre">QueryExpr</span></code>, but should be evaluated to a
boolean.</p>
<p>A <code class="docutils literal notranslate"><span class="pre">mapping</span></code> is a <code class="docutils literal notranslate"><span class="pre">QueryExpr</span></code>, but shouldn’t be evaluated to a
nothing.</p>
<p>FYI, here’re some valid instances about <code class="docutils literal notranslate"><span class="pre">selector</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>_.foo,
_.(!1),
_.(startswith(&quot;bar&quot;), !endswith(&quot;foo&quot;)),
x + _.foo,
let y = _.foo + y; y + _.(2) end
</pre></div>
</div>
</div>
<div class="section" id="codegen-target">
<h2>Codegen Target<a class="headerlink" href="#codegen-target" title="Permalink to this headline">¶</a></h2>
<p>Before implementing code generation, we should have a sketch about the
target. The <strong>target</strong> here means the final shape of the code generated
from a sequence of query clauses.</p>
<p>I’ll take you to the travel within the inference about the final shape
of code generation.</p>
<p>Firstly, for we want this:</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">df</span> <span class="o">|&gt;</span>
<span class="nd">@select</span> <span class="n">_</span><span class="o">.</span><span class="n">foo</span> <span class="o">+</span> <span class="n">x</span><span class="p">,</span> <span class="n">_</span><span class="o">.</span><span class="n">bar</span>
</pre></div>
</div>
<p>We can infer out that the generated code is an anonymous function which
takes only one argument.</p>
<p>Okay, cool. We’ve known that the final shape of generated code should
be:</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="k">function</span> <span class="p">(</span><span class="n">ARG</span><span class="p">)</span>
    <span class="c"># implementations</span>
<span class="k">end</span>
</pre></div>
</div>
<p>Then, let’s think about the <code class="docutils literal notranslate"><span class="pre">select</span></code> clause. You might find it’s a
<code class="docutils literal notranslate"><span class="pre">map</span></code>(if we don’t take aggregrate function into consideration).
However, for we don’t want to make redundant allocations when executing
the queries, so we should use <code class="docutils literal notranslate"><span class="pre">Base.Generator</span></code> as the data
representation.</p>
<p>For <code class="docutils literal notranslate"><span class="pre">&#64;select</span> <span class="pre">_.foo</span> <span class="pre">+</span> <span class="pre">x,</span> <span class="pre">_.bar</span></code>, it should be generated to something
like</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="p">((</span><span class="n">RECORD</span><span class="p">[</span><span class="o">:</span><span class="n">foo</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">,</span> <span class="n">RECORD</span><span class="p">[</span><span class="o">:</span><span class="n">bar</span><span class="p">])</span>   <span class="k">for</span> <span class="n">RECORD</span> <span class="kp">in</span> <span class="n">IN_SOURCE</span><span class="p">)</span>
</pre></div>
</div>
<p>Where <code class="docutils literal notranslate"><span class="pre">IN_SOURCE</span></code> is the data representation, <code class="docutils literal notranslate"><span class="pre">RECORD</span></code> is the
record(row) of <code class="docutils literal notranslate"><span class="pre">IN_SOURCE</span></code>, and <code class="docutils literal notranslate"><span class="pre">x</span></code> is the variable captured by the
closure.</p>
<p>Now, a smart reader might observe that there’s a trick for optimization!
If we can have the actual indices of the fields <code class="docutils literal notranslate"><span class="pre">foo</span></code> and <code class="docutils literal notranslate"><span class="pre">bar</span></code> in
the record(each row of <code class="docutils literal notranslate"><span class="pre">IN_SOURCE</span></code>), then they can be indexed via
integers, which could avoid reflections in some degree.</p>
<p>I don’t have much knowledge about NamedTuple’s implementation, but
indexing via names on unknown datatypes cannot be faster than simply
indexing via integers.</p>
<p>So, the generated code of <code class="docutils literal notranslate"><span class="pre">select</span></code> could be</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">idx_of_foo</span> <span class="o">=</span> <span class="n">findfirst</span><span class="p">(</span><span class="o">==</span><span class="p">(</span><span class="o">:</span><span class="n">foo</span><span class="p">),</span> <span class="n">IN_FIELDS</span><span class="p">),</span>
    <span class="n">idx_of_bar</span> <span class="o">=</span> <span class="n">findfirst</span><span class="p">(</span><span class="o">==</span><span class="p">(</span><span class="o">:</span><span class="n">bar</span><span class="p">),</span> <span class="n">IN_FIELDS</span><span class="p">),</span>
    <span class="nd">@inline</span> <span class="n">FN</span><span class="p">(</span><span class="n">_foo</span><span class="p">,</span> <span class="n">_bar</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">_foo</span> <span class="o">+</span> <span class="n">x</span><span class="p">,</span> <span class="n">_bar</span><span class="p">)</span>
    <span class="p">(</span>
    <span class="k">let</span> <span class="n">_foo</span> <span class="o">=</span> <span class="n">RECORD</span><span class="p">[</span><span class="n">idx_of_foo</span><span class="p">],</span>
        <span class="n">_bar</span> <span class="o">=</span> <span class="n">RECORD</span><span class="p">[</span><span class="n">idx_of_bar</span><span class="p">]</span>
        <span class="n">FN</span><span class="p">(</span><span class="n">_foo</span><span class="p">,</span> <span class="n">_bar</span><span class="p">)</span>
    <span class="k">end</span>
    <span class="k">for</span> <span class="n">RECORD</span> <span class="kp">in</span> <span class="n">IN_SOURCE</span><span class="p">)</span>
<span class="k">end</span>
</pre></div>
</div>
<p>Where we introduce a new requirement of the query’s code generation,
<code class="docutils literal notranslate"><span class="pre">IN_FIELDS</span></code>, which denotes the field names of <code class="docutils literal notranslate"><span class="pre">IN_SOURCE</span></code>.</p>
<p>Now, to have a consistent code generation, let’s think about stacked
<code class="docutils literal notranslate"><span class="pre">select</span></code> clauses.</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">df</span> <span class="o">|&gt;</span>
<span class="nd">@select</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="o">.</span><span class="n">foo</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">=&gt;</span> <span class="n">foo1</span><span class="p">,</span>
<span class="c"># `select _` here means `SELECT *` in T-SQL.</span>
<span class="nd">@select</span> <span class="n">_</span><span class="o">.</span><span class="n">foo1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">=&gt;</span> <span class="n">foo2</span>
</pre></div>
</div>
<p>I don’t know how to explain the iteration in my mind, but I’ve figured
out such a way.</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="p">(</span><span class="n">IN_FIELDS</span><span class="p">,</span> <span class="n">IN_SOURCE</span><span class="p">)</span> <span class="o">=</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">IN_FIELDS</span><span class="p">,</span> <span class="n">IN_SOURCE</span><span class="p">)</span> <span class="o">=</span> <span class="n">process</span><span class="p">(</span><span class="n">df</span><span class="p">),</span>
        <span class="n">idx_of_foo</span> <span class="o">=</span> <span class="n">findfirst</span><span class="p">(</span><span class="o">==</span><span class="p">(</span><span class="o">:</span><span class="n">foo</span><span class="p">),</span> <span class="n">IN_FIELDS</span><span class="p">),</span>
        <span class="nd">@inline</span> <span class="n">FN</span><span class="p">(</span><span class="n">_record</span><span class="p">,</span> <span class="n">_foo</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">_record</span><span class="o">...</span><span class="p">,</span> <span class="n">_foo</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">[</span><span class="n">IN_FIELDS</span><span class="o">...</span><span class="p">,</span> <span class="o">:</span><span class="n">foo1</span><span class="p">],</span>
        <span class="p">(</span>
            <span class="k">let</span> <span class="n">_foo</span> <span class="o">=</span> <span class="n">RECORD</span><span class="p">[</span><span class="n">idx_of_foo</span><span class="p">]</span>
                <span class="n">FN</span><span class="p">(</span><span class="n">RECORD</span><span class="p">,</span> <span class="n">_foo</span><span class="p">)</span>
            <span class="k">end</span>
            <span class="k">for</span> <span class="n">RECORD</span> <span class="kp">in</span> <span class="n">IN_SOURCE</span>
        <span class="p">)</span>
    <span class="k">end</span><span class="p">,</span>
    <span class="n">idx_of_foo1</span> <span class="o">=</span> <span class="n">findfirst</span><span class="p">(</span><span class="o">==</span><span class="p">(</span><span class="o">:</span><span class="n">foo1</span><span class="p">),</span> <span class="n">IN_FIELDS</span><span class="p">),</span>
    <span class="nd">@inline</span> <span class="n">FN</span><span class="p">(</span><span class="n">_foo1</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">_foo1</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="p">)</span>

    <span class="p">[</span><span class="o">:</span><span class="n">foo2</span><span class="p">],</span>
    <span class="p">(</span>
        <span class="k">let</span> <span class="n">_foo1</span> <span class="o">=</span> <span class="n">RECORD</span><span class="p">[</span><span class="n">idx_of_foo1</span><span class="p">]</span>
            <span class="n">FN</span><span class="p">(</span><span class="n">_foo1</span><span class="p">)</span>
        <span class="k">end</span>
        <span class="k">for</span> <span class="n">RECORD</span> <span class="kp">in</span> <span class="n">IN_SOURCE</span>
    <span class="p">)</span>
<span class="k">end</span>
</pre></div>
</div>
<p>Oh, perfect! I’m so excited! That’s so beautiful!</p>
<p>If the output field names are a list of meta variables <code class="docutils literal notranslate"><span class="pre">[:foo2]</span></code>, then
output expression inside the comprehension should be a list of terms
<code class="docutils literal notranslate"><span class="pre">[foo2]</span></code>. For <code class="docutils literal notranslate"><span class="pre">foo2</span> <span class="pre">=</span> <span class="pre">_.foo1</span> <span class="pre">+</span> <span class="pre">2</span></code> which is generated as
<code class="docutils literal notranslate"><span class="pre">RECORD[idx_of_foo1]</span> <span class="pre">+</span> <span class="pre">2</span></code>, so it comes into the shape of above code
snippet.</p>
<p>Let’s think about the <code class="docutils literal notranslate"><span class="pre">where</span></code> clause.</p>
<p>If we want this:</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">df</span> <span class="o">|&gt;</span>
<span class="nd">@where</span> <span class="n">_</span><span class="o">.</span><span class="n">foo</span> <span class="o">&lt;</span> <span class="mi">2</span>
</pre></div>
</div>
<p>That’s similar to <code class="docutils literal notranslate"><span class="pre">select</span></code>:</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="p">(</span><span class="n">IN_FIELDS</span><span class="p">,</span> <span class="n">IN_SOURCE</span><span class="p">)</span> <span class="o">=</span> <span class="n">process</span><span class="p">(</span><span class="n">df</span><span class="p">),</span>
    <span class="n">idx_of_foo</span> <span class="o">=</span> <span class="n">findfirst</span><span class="p">(</span><span class="o">==</span><span class="p">(</span><span class="o">:</span><span class="n">foo</span><span class="p">),</span> <span class="n">IN_FIELDS</span><span class="p">)</span>
    <span class="n">IN_FIELDS</span><span class="p">,</span>
    <span class="p">(</span>
        <span class="n">RECORD</span> <span class="k">for</span> <span class="n">RECORD</span> <span class="kp">in</span> <span class="n">SOURCE</span>
        <span class="k">if</span>  <span class="k">let</span> <span class="n">_foo</span> <span class="o">=</span> <span class="n">RECORD</span><span class="p">[</span><span class="n">idx_of_foo</span><span class="p">]</span>
                <span class="n">_foo</span> <span class="o">&lt;</span> <span class="mi">2</span>
            <span class="k">end</span>
    <span class="p">)</span>
<span class="k">end</span>
</pre></div>
</div>
<p>Obviously that <code class="docutils literal notranslate"><span class="pre">where</span></code> clauses generated in this way could be stacked.</p>
<p>Next, it’s the turn of <code class="docutils literal notranslate"><span class="pre">groupby</span></code>. It could be much more complex, for
we should make it consistent with code generation for <code class="docutils literal notranslate"><span class="pre">select</span></code> and
<code class="docutils literal notranslate"><span class="pre">where</span></code>.</p>
<p>Let’s think about the case below.</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">df</span> <span class="o">|&gt;</span>
<span class="nd">@groupby</span> <span class="n">startswith</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;Ruby&quot;</span><span class="p">)</span>  <span class="o">=&gt;</span> <span class="n">is_ruby</span>
</pre></div>
</div>
<p>Yep, we want to group data frames(of course, any other datatypes that
can be processed via this pipeline) by whether its field <code class="docutils literal notranslate"><span class="pre">name</span></code> starts
with a string “Ruby” like, “Ruby Rose”.</p>
<p>Ha, I’d like to use a dictionary here to store the groups.</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">IN_FIELDS</span><span class="p">,</span> <span class="n">IN_SOURCE</span> <span class="o">=</span> <span class="n">process</span><span class="p">(</span><span class="n">df</span><span class="p">),</span>
    <span class="n">idx_of_name</span> <span class="o">=</span> <span class="n">findfirst</span><span class="p">(</span><span class="o">==</span><span class="p">(</span><span class="o">:</span><span class="n">name</span><span class="p">),</span> <span class="n">IN_FIELDS</span><span class="p">),</span>
    <span class="nd">@inline</span> <span class="n">FN</span><span class="p">(</span><span class="n">_name</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">startswith</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;Ruby&quot;</span><span class="p">),</span> <span class="p">)</span>

    <span class="n">GROUPS</span> <span class="o">=</span> <span class="kt">Dict</span><span class="p">()</span> <span class="c"># the type issues will be discussed later.</span>
    <span class="k">for</span> <span class="n">RECORD</span> <span class="kp">in</span> <span class="n">IN_SOURCE</span>
        <span class="n">_name</span> <span class="o">=</span> <span class="n">RECORD</span><span class="p">[</span><span class="n">idx_of_name</span><span class="p">]</span>
        <span class="n">GROUP_KEY</span> <span class="o">=</span> <span class="p">(</span><span class="n">is_ruby</span><span class="p">,</span> <span class="p">)</span> <span class="o">=</span> <span class="n">FN</span><span class="p">(</span><span class="n">_name</span><span class="p">)</span>
        <span class="n">AGGREGATES</span> <span class="o">=</span> <span class="n">get!</span><span class="p">(</span><span class="n">GROUPS</span><span class="p">,</span> <span class="n">GROUP_KEY</span><span class="p">)</span> <span class="k">do</span>
            <span class="kt">Tuple</span><span class="p">([]</span> <span class="k">for</span> <span class="n">_</span> <span class="kp">in</span> <span class="n">IN_FIELDS</span><span class="p">)</span>
        <span class="k">end</span>
        <span class="n">push!</span><span class="o">.</span><span class="p">(</span><span class="n">AGGREGATES</span><span class="p">,</span> <span class="n">RECORD</span><span class="p">)</span>
    <span class="k">end</span>
    <span class="c"># then output fields and source here</span>
<span class="k">end</span>
</pre></div>
</div>
<p>I think it perfect, so let’s go ahead. The reason why we make an inline
function would be given later, I’d disclosed that it’s for type
inference.</p>
<p>So, what should the output field names and the source be?</p>
<p>An implementation is,</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">IN_FIELDS</span><span class="p">,</span> <span class="n">values</span><span class="p">(</span><span class="n">GROUPS</span><span class="p">)</span>
</pre></div>
</div>
<p>But if so, we will lose the information of group keys, which is not that
good.</p>
<p>So, if we want to persist the group keys, we can do this:</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="o">:</span><span class="n">is_ruby</span><span class="p">];</span> <span class="n">IN_FIELDS</span><span class="p">],</span> <span class="p">((</span><span class="n">k</span><span class="o">...</span><span class="p">,</span> <span class="n">v</span><span class="o">...</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="kp">in</span> <span class="n">GROUPS</span><span class="p">)</span>
</pre></div>
</div>
<p>I think the latter could be sufficiently powerful, although it might not
be that efficient. You can have different implementations of <code class="docutils literal notranslate"><span class="pre">groupby</span></code>
if you have more specific use cases, just use the extensible system
which will be introduced later.</p>
<p>So, the code generation of <code class="docutils literal notranslate"><span class="pre">groupby</span></code> could be:</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">IN_FIELDS</span><span class="p">,</span> <span class="n">IN_SOURCE</span> <span class="o">=</span> <span class="n">process</span><span class="p">(</span><span class="n">df</span><span class="p">),</span>
    <span class="n">idx_of_name</span> <span class="o">=</span> <span class="n">findfirst</span><span class="p">(</span><span class="o">==</span><span class="p">(</span><span class="o">:</span><span class="n">name</span><span class="p">),</span> <span class="n">IN_FIELDS</span><span class="p">),</span>
    <span class="nd">@inline</span> <span class="n">FN</span><span class="p">(</span><span class="n">_name</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">startswith</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;Ruby&quot;</span><span class="p">),</span> <span class="p">)</span>

    <span class="n">GROUPS</span> <span class="o">=</span> <span class="kt">Dict</span><span class="p">()</span> <span class="c"># the type issues will be discussed later.</span>
    <span class="k">for</span> <span class="n">RECORD</span> <span class="kp">in</span> <span class="n">IN_SOURCE</span>
        <span class="n">_name</span> <span class="o">=</span> <span class="n">RECORD</span><span class="p">[</span><span class="n">idx_of_name</span><span class="p">]</span>
        <span class="n">GROUP_KEY</span> <span class="o">=</span> <span class="p">(</span><span class="n">is_ruby</span><span class="p">,</span> <span class="p">)</span> <span class="o">=</span> <span class="n">FN</span><span class="p">(</span><span class="n">_name</span><span class="p">)</span>
        <span class="n">AGGREGATES</span> <span class="o">=</span> <span class="n">get!</span><span class="p">(</span><span class="n">GROUPS</span><span class="p">,</span> <span class="n">GROUP_KEY</span><span class="p">)</span> <span class="k">do</span>
            <span class="kt">Tuple</span><span class="p">([]</span> <span class="k">for</span> <span class="n">_</span> <span class="kp">in</span> <span class="n">IN_FIELDS</span><span class="p">)</span>
        <span class="k">end</span>
        <span class="n">push!</span><span class="o">.</span><span class="p">(</span><span class="n">AGGREGATES</span><span class="p">,</span> <span class="n">RECORD</span><span class="p">)</span>
    <span class="k">end</span>
    <span class="p">[[</span><span class="o">:</span><span class="n">is_ruby</span><span class="p">];</span> <span class="n">IN_FIELDS</span><span class="p">],</span> <span class="p">((</span><span class="n">k</span><span class="o">...</span><span class="p">,</span> <span class="n">v</span><span class="o">...</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="kp">in</span> <span class="n">GROUPS</span><span class="p">)</span>
<span class="k">end</span>
</pre></div>
</div>
<p>However, subsequently, we comes to the <code class="docutils literal notranslate"><span class="pre">having</span></code> clause, in fact, I’d
regard it as a sub-clause of <code class="docutils literal notranslate"><span class="pre">groupby</span></code>, which means it cannot take
place indenpendently, but co-appear with a <code class="docutils literal notranslate"><span class="pre">groupby</span></code> clause.</p>
<p>Given such a case:</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">df</span> <span class="o">|&gt;</span>
<span class="nd">@groupby</span> <span class="n">startswith</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;Ruby&quot;</span><span class="p">)</span>  <span class="o">=&gt;</span> <span class="n">is_ruby</span>
<span class="nd">@having</span> <span class="n">is_ruby</span> <span class="o">||</span> <span class="n">count</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">is_rose</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">5</span>
</pre></div>
</div>
<p>The generated code should be:</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">IN_FIELDS</span><span class="p">,</span> <span class="n">IN_SOURCE</span> <span class="o">=</span> <span class="n">process</span><span class="p">(</span><span class="n">df</span><span class="p">),</span>
    <span class="n">idx_of_name</span> <span class="o">=</span> <span class="n">findfirst</span><span class="p">(</span><span class="o">==</span><span class="p">(</span><span class="o">:</span><span class="n">name</span><span class="p">),</span> <span class="n">IN_FIELDS</span><span class="p">),</span>
    <span class="n">idx_of_is_rose</span> <span class="o">=</span> <span class="n">findfirst</span><span class="p">(</span><span class="o">==</span><span class="p">(</span><span class="o">:</span><span class="n">is_rose</span><span class="p">),</span> <span class="n">IN_FIELDS</span><span class="p">)</span>
    <span class="nd">@inline</span> <span class="n">FN</span><span class="p">(</span><span class="n">_name</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">startswith</span><span class="p">(</span><span class="n">_name</span><span class="p">,</span> <span class="s">&quot;Ruby&quot;</span><span class="p">),</span> <span class="p">)</span>

    <span class="n">GROUPS</span> <span class="o">=</span> <span class="kt">Dict</span><span class="p">()</span> <span class="c"># the type issues will be discussed later.</span>
    <span class="k">for</span> <span class="n">RECORD</span> <span class="kp">in</span> <span class="n">IN_SOURCE</span>
        <span class="n">_name</span> <span class="o">=</span> <span class="n">RECORD</span><span class="p">[</span><span class="n">idx_of_name</span><span class="p">]</span>
        <span class="n">_is_rose</span> <span class="o">=</span> <span class="n">RECORD</span><span class="p">[</span><span class="n">idx_of_rose</span><span class="p">]</span>
        <span class="n">GROUP_KEY</span> <span class="o">=</span> <span class="p">(</span><span class="n">is_ruby</span><span class="p">,</span> <span class="p">)</span> <span class="o">=</span> <span class="n">GROUP_FN</span><span class="p">(</span><span class="n">RECORD</span><span class="p">)</span>
        <span class="k">if</span> <span class="o">!</span><span class="p">(</span><span class="n">is_ruby</span> <span class="o">||</span> <span class="n">count</span><span class="p">(</span><span class="n">is_rose</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">)</span>
            <span class="k">continue</span>
        <span class="k">end</span>
        <span class="n">AGGREGATES</span> <span class="o">=</span> <span class="n">get!</span><span class="p">(</span><span class="n">GROUPS</span><span class="p">,</span> <span class="n">GROUP_KEY</span><span class="p">)</span> <span class="k">do</span>
            <span class="kt">Tuple</span><span class="p">([]</span> <span class="k">for</span> <span class="n">_</span> <span class="kp">in</span> <span class="n">IN_FIELDS</span><span class="p">)</span>
        <span class="k">end</span>
        <span class="n">push!</span><span class="o">.</span><span class="p">(</span><span class="n">AGGREGATES</span><span class="p">,</span> <span class="n">RECORD</span><span class="p">)</span>
    <span class="k">end</span>
    <span class="p">[[</span><span class="o">:</span><span class="n">is_ruby</span><span class="p">];</span> <span class="n">IN_FIELDS</span><span class="p">],</span> <span class="p">((</span><span class="n">k</span><span class="o">...</span><span class="p">,</span> <span class="n">v</span><span class="o">...</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="kp">in</span> <span class="n">GROUPS</span><span class="p">)</span>
<span class="k">end</span>
</pre></div>
</div>
<p>The conditional code generation of <code class="docutils literal notranslate"><span class="pre">groupby</span></code> could be achieved very
concisely via AST patterns of MLStyle, we’ll refer to this later.</p>
<p>After introducing the generation for above 4 clauses, <code class="docutils literal notranslate"><span class="pre">orderby</span></code> and
<code class="docutils literal notranslate"><span class="pre">limit</span></code> then become quite trivial, and I don’t want to repeat myself
if not necessary.</p>
<p>Now we know that mulitiple clauses could be generated to produce a
<code class="docutils literal notranslate"><span class="pre">Tuple</span></code> result, first of which is the field names, the second is the
lazy computation of the query. We can resume this tuple to the
corresponding types, for instance,</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="k">function</span> <span class="p">(</span><span class="n">ARG</span> <span class="o">::</span> <span class="n">DataFrame</span><span class="p">)</span>
    <span class="p">(</span><span class="n">IN_FIELDS</span><span class="p">,</span> <span class="n">IN_SOURCE</span><span class="p">)</span> <span class="o">=</span> <span class="k">let</span> <span class="n">IN_FIELDS</span><span class="p">,</span> <span class="n">IN_SOURCE</span> <span class="o">=</span> <span class="o">...</span>
        <span class="o">...</span>
    <span class="k">end</span>

    <span class="n">res</span> <span class="o">=</span> <span class="kt">Tuple</span><span class="p">([]</span> <span class="k">for</span> <span class="n">_</span> <span class="kp">in</span> <span class="n">IN_FIELDS</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">each</span> <span class="kp">in</span> <span class="n">IN_SOURCE</span>
        <span class="n">push!</span><span class="o">.</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">each</span><span class="p">)</span>
    <span class="k">end</span>
    <span class="n">DataFrame</span><span class="p">(</span><span class="n">collect</span><span class="p">(</span><span class="n">res</span><span class="p">),</span> <span class="n">IN_FIELDS</span><span class="p">)</span>
<span class="k">end</span>
</pre></div>
</div>
</div>
<div class="section" id="refinement-of-codegen-typed-columns">
<h2>Refinement of Codegen: Typed Columns<a class="headerlink" href="#refinement-of-codegen-typed-columns" title="Permalink to this headline">¶</a></h2>
<p>Last section introduce a framework of code generation for implementing
query langauges, but in Julia, there’s still a fatal problem.</p>
<p>Look at the value to be return(when input is a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>):</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">res</span> <span class="o">=</span> <span class="kt">Tuple</span><span class="p">([]</span> <span class="k">for</span> <span class="n">_</span> <span class="kp">in</span> <span class="n">IN_FIELDS</span><span class="p">)</span>
<span class="k">for</span> <span class="n">each</span> <span class="kp">in</span> <span class="n">SOURCE</span>
    <span class="n">push!</span><span class="o">.</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">each</span><span class="p">)</span>
<span class="k">end</span>
<span class="n">DataFrame</span><span class="p">(</span><span class="n">collect</span><span class="p">(</span><span class="n">res</span><span class="p">),</span> <span class="n">collect</span><span class="p">(</span><span class="n">IN_FIELDS</span><span class="p">))</span>
</pre></div>
</div>
<p>I can promise you that, each column of your data frames is a
<code class="docutils literal notranslate"><span class="pre">Vector{Any}</span></code>, yes, not its actual type. You may prefer to calculate
the type of a column using the common super type of all elements, but
there’re 2 problems if you try this:</p>
<ul class="simple">
<li>If the column is empty, emmmm…</li>
<li>Calculating the super type of all elements causes unaffordable cost!</li>
</ul>
<p>Yet, I’ll introduce a new requirement <code class="docutils literal notranslate"><span class="pre">IN_TYPES</span></code> of the query’s code
generation, which perfectly solves problems of column types.</p>
<p>Let’s have a look at code generation for <code class="docutils literal notranslate"><span class="pre">select</span></code> after introducing
the <code class="docutils literal notranslate"><span class="pre">IN_TYPES</span></code>.</p>
<p>Given that</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="nd">@select</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="o">.</span><span class="n">foo</span> <span class="o">+</span> <span class="mi">1</span>
<span class="c"># `@select _` is regarded as `SELECT *` in T-SQL.</span>
</pre></div>
</div>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">return_type</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">ts</span><span class="p">)</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">ts</span> <span class="o">=</span> <span class="n">Base</span><span class="o">.</span><span class="n">return_types</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">ts</span><span class="p">)</span>
        <span class="n">length</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span> <span class="o">===</span> <span class="mi">1</span> <span class="o">?</span>
            <span class="n">ts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>        <span class="o">:</span>
            <span class="kt">Union</span><span class="p">{</span><span class="n">ts</span><span class="o">...</span><span class="p">}</span>
    <span class="k">end</span>
<span class="n">type_unpack</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="o">::</span><span class="kt">Type</span><span class="p">{</span><span class="kt">Tuple</span><span class="p">{}})</span> <span class="o">=</span> <span class="n">throw</span><span class="p">(</span><span class="s">&quot;error&quot;</span><span class="p">)</span>
<span class="n">type_unpack</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="o">::</span><span class="kt">Type</span><span class="p">{</span><span class="kt">Tuple</span><span class="p">{</span><span class="n">T1</span><span class="p">}})</span> <span class="n">where</span> <span class="n">T1</span> <span class="o">=</span> <span class="p">[</span><span class="n">T1</span><span class="p">]</span>
<span class="n">type_unpack</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="o">::</span><span class="kt">Type</span><span class="p">{</span><span class="kt">Tuple</span><span class="p">{</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">}})</span> <span class="n">where</span> <span class="p">{</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">}</span> <span class="o">=</span> <span class="p">[</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">]</span>
<span class="c"># type_unpack(::Type{Tuple{T1, T2, ...}}) where {T1, T2, ...} = [T1, T2, ...]</span>
<span class="n">type_unpack</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="o">::</span><span class="kt">Type</span><span class="p">{</span><span class="kt">Any</span><span class="p">})</span> <span class="o">=</span> <span class="n">fill</span><span class="p">(</span><span class="kt">Any</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

<span class="k">let</span> <span class="p">(</span><span class="n">IN_FIELDS</span><span class="p">,</span> <span class="n">IN_TYPES</span><span class="p">,</span> <span class="n">SOURCE</span><span class="p">)</span> <span class="o">=</span> <span class="n">process</span><span class="p">(</span><span class="n">df</span><span class="p">),</span>
    <span class="n">idx_of_foo</span> <span class="o">=</span> <span class="n">findfirst</span><span class="p">(</span><span class="o">==</span><span class="p">(</span><span class="o">:</span><span class="n">foo</span><span class="p">),</span>  <span class="n">IN_FIELDS</span><span class="p">),</span>
    <span class="p">(</span><span class="nd">@inline</span> <span class="n">FN</span><span class="p">(</span><span class="n">_record</span><span class="p">,</span> <span class="n">_foo</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">_record</span><span class="o">...</span><span class="p">,</span> <span class="n">_foo</span><span class="p">)),</span>
    <span class="n">FN_OUT_FIELDS</span> <span class="o">=</span> <span class="p">[</span><span class="n">IN_FIELDS</span><span class="o">...</span><span class="p">,</span> <span class="o">:</span><span class="n">foo1</span><span class="p">],</span>
    <span class="n">FN_OUT_TYPES</span> <span class="o">=</span> <span class="n">type_unpack</span><span class="p">(</span><span class="n">length</span><span class="p">(</span><span class="n">FN_OUT_FIELDS</span><span class="p">),</span> <span class="n">return_type</span><span class="p">(</span><span class="kt">Tuple</span><span class="p">{</span><span class="n">IN_TYPES</span><span class="o">...</span><span class="p">},</span> <span class="n">IN_TYPES</span><span class="p">[</span><span class="n">idx_of_foo</span><span class="p">]))</span>

    <span class="n">FN_OUT_FILEDS</span><span class="p">,</span>
    <span class="n">FN_OUT_TYPES</span><span class="p">,</span>
    <span class="p">(</span><span class="k">let</span> <span class="n">_foo</span> <span class="o">=</span> <span class="n">RECORD</span><span class="p">[</span><span class="n">idx_of_foo</span><span class="p">];</span> <span class="n">FN</span><span class="p">(</span><span class="n">RECORD</span><span class="p">,</span> <span class="n">_foo</span><span class="p">)</span> <span class="k">end</span> <span class="k">for</span> <span class="n">RECORD</span> <span class="kp">in</span> <span class="n">SOURCE</span><span class="p">)</span>
<span class="k">end</span>
</pre></div>
</div>
<p>For <code class="docutils literal notranslate"><span class="pre">groupby</span></code>, it could be a bit more complex, but it does nothing new
towards what <code class="docutils literal notranslate"><span class="pre">select</span></code> does. You can check <a class="reference external" href="https://github.com/thautwarm/MLStyle-Playground/tree/master/MQuery">the
repo</a>
for codes.</p>
</div>
<div class="section" id="implementation">
<h2>Implementation<a class="headerlink" href="#implementation" title="Permalink to this headline">¶</a></h2>
<p>Firstly, we should define something like constants and helper functions.</p>
<p>FYI, some constants and interfaces are defined at
<a class="reference external" href="https://github.com/thautwarm/MLStyle-Playground/blob/master/MQuery/MQuery.ConstantNames.jl">MQuery.ConstantNames.jl</a>
and
<a class="reference external" href="https://github.com/thautwarm/MLStyle-Playground/blob/master/MQuery/MQuery.Interfaces.jl">MQuery.Interfaces.jl</a>,
you might want to refer to them if any unknown symbol prevents you from
understanding this sketch.</p>
<p>Then we should extract all clauses from a piece of given julia codes.</p>
<p>Given following codes,</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="nd">@select</span> <span class="n">args1</span><span class="p">,</span>
<span class="nd">@where</span> <span class="n">args2</span><span class="p">,</span>
<span class="nd">@select</span> <span class="n">args3</span>
</pre></div>
</div>
<p>, we transform them into</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="p">[(</span><span class="n">generate_select</span><span class="p">,</span> <span class="n">args</span><span class="p">),</span> <span class="p">(</span><span class="n">generate_where</span><span class="p">,</span> <span class="n">args2</span><span class="p">),</span> <span class="p">(</span><span class="n">generate_select</span><span class="p">,</span> <span class="n">args3</span><span class="p">)]</span>
</pre></div>
</div>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="k">function</span> <span class="n">generate_select</span>
<span class="k">end</span>
<span class="k">function</span> <span class="n">generate_where</span>
<span class="k">end</span>
<span class="k">function</span> <span class="n">generate_groupby</span>
<span class="k">end</span>
<span class="k">function</span> <span class="n">generate_orderby</span>
<span class="k">end</span>
<span class="k">function</span> <span class="n">generate_having</span>
<span class="k">end</span>
<span class="k">function</span> <span class="n">generate_limit</span>
<span class="k">end</span>

<span class="kd">const</span> <span class="n">registered_ops</span> <span class="o">=</span> <span class="kt">Dict</span><span class="p">{</span><span class="kt">Symbol</span><span class="p">,</span> <span class="kt">Any</span><span class="p">}(</span>
    <span class="kt">Symbol</span><span class="p">(</span><span class="s">&quot;@select&quot;</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">generate_select</span><span class="p">,</span>
    <span class="kt">Symbol</span><span class="p">(</span><span class="s">&quot;@where&quot;</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">generate_where</span><span class="p">,</span>
    <span class="kt">Symbol</span><span class="p">(</span><span class="s">&quot;@groupby&quot;</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">generate_groupby</span><span class="p">,</span>
    <span class="kt">Symbol</span><span class="p">(</span><span class="s">&quot;@having&quot;</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">generate_having</span><span class="p">,</span>
    <span class="kt">Symbol</span><span class="p">(</span><span class="s">&quot;@limit&quot;</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">generate_limit</span><span class="p">,</span>
    <span class="kt">Symbol</span><span class="p">(</span><span class="s">&quot;@orderby&quot;</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">generate_orderby</span>
<span class="p">)</span>

<span class="k">function</span> <span class="n">get_op</span><span class="p">(</span><span class="n">op_name</span><span class="p">)</span>
    <span class="n">registered_ops</span><span class="p">[</span><span class="n">op_name</span><span class="p">]</span>
<span class="k">end</span>

<span class="n">ismacro</span><span class="p">(</span><span class="n">x</span> <span class="o">::</span> <span class="kt">Expr</span><span class="p">)</span> <span class="o">=</span> <span class="n">Meta</span><span class="o">.</span><span class="n">isexpr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">:</span><span class="n">macrocall</span><span class="p">)</span>
<span class="n">ismacro</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="kc">false</span>

<span class="k">function</span> <span class="n">flatten_macros</span><span class="p">(</span><span class="n">node</span> <span class="o">::</span> <span class="kt">Expr</span><span class="p">)</span>
    <span class="nd">@match</span> <span class="n">node</span> <span class="k">begin</span>
    <span class="kt">Expr</span><span class="p">(</span><span class="o">:</span><span class="n">macrocall</span><span class="p">,</span> <span class="n">op</span> <span class="o">::</span> <span class="kt">Symbol</span><span class="p">,</span> <span class="o">::</span><span class="kt">LineNumberNode</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span> <span class="o">||</span>
    <span class="kt">Expr</span><span class="p">(</span><span class="o">:</span><span class="n">macrocall</span><span class="p">,</span> <span class="n">op</span> <span class="o">::</span> <span class="kt">Symbol</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span> <span class="o">=&gt;</span>

    <span class="nd">@match</span> <span class="n">arg</span> <span class="k">begin</span>
    <span class="kt">Expr</span><span class="p">(</span><span class="o">:</span><span class="n">tuple</span><span class="p">,</span> <span class="n">args</span><span class="o">...</span><span class="p">)</span> <span class="o">||</span> <span class="n">a</span> <span class="o">&amp;&amp;</span> <span class="n">Do</span><span class="p">(</span><span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">])</span> <span class="o">=&gt;</span>

    <span class="nd">@match</span> <span class="n">args</span> <span class="k">begin</span>
    <span class="p">[</span><span class="n">args</span><span class="o">...</span><span class="p">,</span> <span class="n">tl</span> <span class="o">&amp;&amp;</span> <span class="k">if</span> <span class="n">ismacro</span><span class="p">(</span><span class="n">tl</span><span class="p">)</span> <span class="k">end</span><span class="p">]</span> <span class="o">=&gt;</span> <span class="p">[(</span><span class="n">op</span> <span class="o">|&gt;</span> <span class="n">get_op</span><span class="p">,</span> <span class="n">args</span><span class="p">),</span> <span class="n">flatten_macros</span><span class="p">(</span><span class="n">tl</span><span class="p">)</span><span class="o">...</span><span class="p">]</span>
    <span class="n">_</span> <span class="o">=&gt;</span> <span class="p">[(</span><span class="n">op</span> <span class="o">|&gt;</span> <span class="n">get_op</span><span class="p">,</span> <span class="n">args</span><span class="p">)]</span>
    <span class="k">end</span>
    <span class="k">end</span>
    <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>The core is <code class="docutils literal notranslate"><span class="pre">flatten_macros</span></code>, it destructures <code class="docutils literal notranslate"><span class="pre">macrocall</span></code>
expressions and then we can simply flatten the <code class="docutils literal notranslate"><span class="pre">macrocall</span></code>s.</p>
<p>Next, we could have a common behaviour of code generation.</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">Field</span>
    <span class="n">name</span>      <span class="o">::</span> <span class="kt">Any</span>    <span class="c"># an expr to represent the field name from IN_FIELDS.</span>
    <span class="n">make</span>      <span class="o">::</span> <span class="kt">Any</span>    <span class="c"># an expression to assign the value into `var` like, `RECORD[idx_of_foo]`.</span>
    <span class="n">var</span>       <span class="o">::</span> <span class="kt">Symbol</span> <span class="c"># a generated symbol via mangling</span>
    <span class="n">typ</span>       <span class="o">::</span> <span class="kt">Any</span>    <span class="c"># an expression to get the type of the field like, `IN_TYPES[idx_of_foo]`.</span>
<span class="k">end</span>

<span class="k">function</span> <span class="n">query_routine</span><span class="p">(</span><span class="n">assigns</span>            <span class="o">::</span> <span class="n">OrderedDict</span><span class="p">{</span><span class="kt">Symbol</span><span class="p">,</span> <span class="kt">Any</span><span class="p">},</span>
                       <span class="n">fn_in_fields</span>       <span class="o">::</span> <span class="kt">Vector</span><span class="p">{</span><span class="n">Field</span><span class="p">},</span>
                       <span class="n">fn_returns</span>         <span class="o">::</span> <span class="kt">Any</span><span class="p">,</span>
                       <span class="n">result</span><span class="p">;</span> <span class="n">infer_type</span> <span class="o">=</span> <span class="kc">true</span><span class="p">)</span>
    <span class="nd">@assert</span> <span class="n">haskey</span><span class="p">(</span><span class="n">assigns</span><span class="p">,</span> <span class="n">FN_OUT_FIELDS</span><span class="p">)</span>

    <span class="n">fn_arguments</span> <span class="o">=</span> <span class="n">map</span><span class="p">(</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">.</span><span class="n">var</span><span class="p">,</span> <span class="n">fn_in_fields</span><span class="p">)</span>
    <span class="n">fn_arg_types</span> <span class="o">=</span> <span class="kt">Expr</span><span class="p">(</span><span class="o">:</span><span class="n">vect</span><span class="p">,</span> <span class="n">map</span><span class="p">(</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">.</span><span class="n">typ</span><span class="p">,</span> <span class="n">fn_in_fields</span><span class="p">)</span><span class="o">...</span><span class="p">)</span>

    <span class="k">function</span> <span class="p">(</span><span class="n">inner_expr</span><span class="p">)</span>
        <span class="n">let_seq</span> <span class="o">=</span> <span class="p">[</span>
            <span class="kt">Expr</span><span class="p">(</span><span class="o">:</span><span class="p">(</span><span class="o">=</span><span class="p">),</span> <span class="kt">Expr</span><span class="p">(</span><span class="o">:</span><span class="n">tuple</span><span class="p">,</span> <span class="n">IN_FIELDS</span><span class="p">,</span> <span class="n">IN_TYPES</span><span class="p">,</span> <span class="n">IN_SOURCE</span><span class="p">),</span> <span class="n">inner_expr</span><span class="p">),</span>
            <span class="p">(</span><span class="o">:</span><span class="p">(</span><span class="o">$</span><span class="n">name</span> <span class="o">=</span> <span class="o">$</span><span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="kp">in</span> <span class="n">assigns</span><span class="p">)</span><span class="o">...</span><span class="p">,</span>
            <span class="o">:</span><span class="p">(</span><span class="nd">@inline</span> <span class="o">$</span><span class="n">FN</span><span class="p">(</span><span class="o">$</span><span class="p">(</span><span class="n">fn_arguments</span><span class="o">...</span><span class="p">))</span> <span class="o">=</span>  <span class="o">$</span><span class="n">fn_returns</span><span class="p">),</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="n">infer_type</span>
            <span class="k">let</span> <span class="n">type_infer</span> <span class="o">=</span> <span class="o">:</span><span class="p">(</span><span class="o">$</span><span class="n">FN_RETURN_TYPES</span> <span class="o">=</span> <span class="o">$</span><span class="n">type_unpack</span><span class="p">(</span><span class="o">$</span><span class="n">length</span><span class="p">(</span><span class="o">$</span><span class="n">FN_OUT_FIELDS</span><span class="p">,</span> <span class="p">),</span> <span class="o">$</span><span class="n">return_type</span><span class="p">(</span><span class="o">$</span><span class="n">FN</span><span class="p">,</span> <span class="o">$</span><span class="n">fn_arg_types</span><span class="p">)))</span>
                <span class="n">push!</span><span class="p">(</span><span class="n">let_seq</span><span class="p">,</span> <span class="n">type_infer</span><span class="p">)</span>
            <span class="k">end</span>
        <span class="k">end</span>
        <span class="kt">Expr</span><span class="p">(</span><span class="o">:</span><span class="k">let</span><span class="p">,</span>
            <span class="kt">Expr</span><span class="p">(</span>
                <span class="o">:</span><span class="n">block</span><span class="p">,</span>
                <span class="n">let_seq</span><span class="o">...</span>
            <span class="p">),</span>
            <span class="n">result</span>
        <span class="p">)</span>
    <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>In fact, <code class="docutils literal notranslate"><span class="pre">query_routine</span></code> generates code like</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">IN_FIELDS</span><span class="p">,</span> <span class="n">IN_TYPES</span><span class="p">,</span> <span class="n">IN_SOURCE</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">inner</span> <span class="n">query</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">idx_of_foo</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="n">idx_of_bar</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="nd">@inline</span> <span class="n">FN</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="o">...</span>

    <span class="o">...</span>
<span class="k">end</span>
</pre></div>
</div>
<p>Then, we should generate the final code from such a sequence given as
the return of <code class="docutils literal notranslate"><span class="pre">flatten_macros</span></code>.</p>
<p>Note that <code class="docutils literal notranslate"><span class="pre">get_records</span></code>, <code class="docutils literal notranslate"><span class="pre">get_fields</span></code> and <code class="docutils literal notranslate"><span class="pre">build_result</span></code> should be
implemented by your own to support datatypes that you want to query on.</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="k">function</span> <span class="n">codegen</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="n">ops</span> <span class="o">=</span> <span class="n">flatten_macros</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="k">let</span> <span class="n">rec</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span> <span class="o">=</span>
        <span class="nd">@match</span> <span class="n">vec</span> <span class="k">begin</span>
            <span class="p">[]</span> <span class="o">=&gt;</span> <span class="p">[]</span>
            <span class="p">[(</span><span class="o">&amp;</span><span class="n">generate_groupby</span><span class="p">,</span> <span class="n">args1</span><span class="p">),</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">generate_having</span><span class="p">,</span> <span class="n">args2</span><span class="p">),</span> <span class="n">tl</span><span class="o">...</span><span class="p">]</span> <span class="o">=&gt;</span>
                <span class="p">[</span><span class="n">generate_groupby</span><span class="p">(</span><span class="n">args1</span><span class="p">,</span> <span class="n">args2</span><span class="p">),</span> <span class="n">rec</span><span class="p">(</span><span class="n">tl</span><span class="p">)</span><span class="o">...</span><span class="p">]</span>
            <span class="p">[(</span><span class="n">hd</span><span class="p">,</span> <span class="n">args</span><span class="p">),</span> <span class="n">tl</span><span class="o">...</span><span class="p">]</span> <span class="o">=&gt;</span>
                <span class="p">[</span><span class="n">hd</span><span class="p">(</span><span class="n">args</span><span class="p">),</span> <span class="n">rec</span><span class="p">(</span><span class="n">tl</span><span class="p">)</span><span class="o">...</span><span class="p">]</span>
        <span class="k">end</span>
        <span class="n">init</span> <span class="o">=</span> <span class="k">quote</span>
            <span class="k">let</span> <span class="n">iter</span> <span class="o">=</span> <span class="o">$</span><span class="n">get_records</span><span class="p">(</span><span class="o">$</span><span class="n">ARG</span><span class="p">),</span>
                <span class="n">fields</span> <span class="o">=</span> <span class="o">$</span><span class="n">get_fields</span><span class="p">(</span><span class="o">$</span><span class="n">ARG</span><span class="p">),</span>
                <span class="n">types</span> <span class="o">=$</span><span class="n">type_unpack</span><span class="p">(</span><span class="o">$</span><span class="n">length</span><span class="p">(</span><span class="n">fields</span><span class="p">),</span> <span class="o">$</span><span class="n">eltype</span><span class="p">(</span><span class="n">iter</span><span class="p">))</span>
                <span class="p">(</span><span class="n">fields</span><span class="p">,</span> <span class="n">types</span><span class="p">,</span> <span class="n">iter</span><span class="p">)</span>
            <span class="k">end</span>
        <span class="k">end</span>
        <span class="n">fn_body</span> <span class="o">=</span> <span class="n">foldl</span><span class="p">(</span><span class="n">rec</span><span class="p">(</span><span class="n">ops</span><span class="p">),</span> <span class="n">init</span> <span class="o">=</span> <span class="n">init</span><span class="p">)</span> <span class="k">do</span> <span class="n">last</span><span class="p">,</span> <span class="n">mk</span>
            <span class="n">mk</span><span class="p">(</span><span class="n">last</span><span class="p">)</span>
        <span class="k">end</span>
        <span class="k">quote</span>
            <span class="nd">@inline</span> <span class="k">function</span> <span class="p">(</span><span class="o">$</span><span class="n">ARG</span> <span class="o">::</span> <span class="o">$</span><span class="n">TYPE_ROOT</span><span class="p">,</span> <span class="p">)</span> <span class="n">where</span> <span class="p">{</span><span class="o">$</span><span class="n">TYPE_ROOT</span><span class="p">}</span>
                <span class="k">let</span> <span class="p">(</span><span class="o">$</span><span class="n">IN_FIELDS</span><span class="p">,</span> <span class="o">$</span><span class="n">IN_TYPES</span><span class="p">,</span> <span class="o">$</span><span class="n">IN_SOURCE</span><span class="p">)</span> <span class="o">=</span> <span class="o">$</span><span class="n">fn_body</span>
                    <span class="o">$</span><span class="n">build_result</span><span class="p">(</span>
                        <span class="o">$</span><span class="n">TYPE_ROOT</span><span class="p">,</span>
                        <span class="o">$</span><span class="n">IN_FIELDS</span><span class="p">,</span>
                        <span class="o">$</span><span class="n">IN_TYPES</span><span class="p">,</span>
                        <span class="o">$</span><span class="n">IN_SOURCE</span>
                    <span class="p">)</span>
                <span class="k">end</span>
            <span class="k">end</span>
        <span class="k">end</span>
    <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>Then, we need a visitor to transform the patterns shaped as <code class="docutils literal notranslate"><span class="pre">_.foo</span></code>
inside an expression to a mangled symbol whose value is
<code class="docutils literal notranslate"><span class="pre">RECORD[idx_of_foo]</span></code>.</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="c"># visitor to process the pattern `_.x, _,&quot;x&quot;, _.(1)` inside an expression</span>
<span class="k">function</span> <span class="n">mk_visit</span><span class="p">(</span><span class="n">fields</span> <span class="o">::</span> <span class="kt">Dict</span><span class="p">{</span><span class="kt">Any</span><span class="p">,</span> <span class="n">Field</span><span class="p">},</span> <span class="n">assigns</span> <span class="o">::</span> <span class="n">OrderedDict</span><span class="p">{</span><span class="kt">Symbol</span><span class="p">,</span> <span class="kt">Any</span><span class="p">})</span>
    <span class="n">visit</span> <span class="o">=</span> <span class="n">expr</span> <span class="o">-&gt;</span>
    <span class="nd">@match</span> <span class="n">expr</span> <span class="k">begin</span>
        <span class="kt">Expr</span><span class="p">(</span><span class="o">:.</span> <span class="p">,</span> <span class="o">:</span><span class="n">_</span><span class="p">,</span> <span class="n">q</span> <span class="o">::</span> <span class="kt">QuoteNode</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">Do</span><span class="p">(</span><span class="n">a</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="o">||</span>
        <span class="kt">Expr</span><span class="p">(</span><span class="o">:.</span><span class="p">,</span> <span class="o">:</span><span class="n">_</span><span class="p">,</span> <span class="kt">Expr</span><span class="p">(</span><span class="o">:</span><span class="n">tuple</span><span class="p">,</span> <span class="n">a</span><span class="p">))</span> <span class="o">=&gt;</span>
            <span class="nd">@match</span> <span class="n">a</span> <span class="k">begin</span>
                <span class="n">a</span> <span class="o">::</span> <span class="kt">Int</span> <span class="o">=&gt;</span>
                    <span class="k">let</span> <span class="n">field</span> <span class="o">=</span> <span class="n">get!</span><span class="p">(</span><span class="n">fields</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="k">do</span>
                            <span class="n">var_sym</span> <span class="o">=</span> <span class="n">gen_sym</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
                            <span class="n">Field</span><span class="p">(</span>
                                <span class="n">a</span><span class="p">,</span>
                                <span class="kt">Expr</span><span class="p">(</span><span class="o">:</span><span class="n">ref</span><span class="p">,</span> <span class="n">RECORD</span><span class="p">,</span> <span class="n">a</span><span class="p">),</span>
                                <span class="n">var_sym</span><span class="p">,</span>
                                <span class="kt">Expr</span><span class="p">(</span><span class="o">:</span><span class="n">ref</span><span class="p">,</span> <span class="n">IN_TYPES</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
                            <span class="p">)</span>
                        <span class="k">end</span>
                        <span class="n">field</span><span class="o">.</span><span class="n">var</span>
                    <span class="k">end</span>

                <span class="o">::</span><span class="n">String</span> <span class="o">&amp;&amp;</span> <span class="n">Do</span><span class="p">(</span><span class="n">b</span> <span class="o">=</span> <span class="kt">Symbol</span><span class="p">(</span><span class="n">a</span><span class="p">))</span> <span class="o">||</span>
                <span class="n">b</span><span class="o">::</span><span class="kt">Symbol</span> <span class="o">=&gt;</span>
                    <span class="k">let</span> <span class="n">field</span> <span class="o">=</span> <span class="n">get!</span><span class="p">(</span><span class="n">fields</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="k">do</span>
                            <span class="n">idx_sym</span> <span class="o">=</span> <span class="n">gen_sym</span><span class="p">()</span>
                            <span class="n">var_sym</span> <span class="o">=</span> <span class="n">gen_sym</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
                            <span class="n">assigns</span><span class="p">[</span><span class="n">idx_sym</span><span class="p">]</span> <span class="o">=</span> <span class="kt">Expr</span><span class="p">(</span><span class="o">:</span><span class="n">call</span><span class="p">,</span> <span class="n">findfirst</span><span class="p">,</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">===</span> <span class="n">b</span><span class="p">,</span> <span class="n">IN_FIELDS</span><span class="p">)</span>
                            <span class="n">Field</span><span class="p">(</span>
                                <span class="n">b</span><span class="p">,</span>
                                <span class="kt">Expr</span><span class="p">(</span><span class="o">:</span><span class="n">ref</span><span class="p">,</span> <span class="n">RECORD</span><span class="p">,</span> <span class="n">idx_sym</span><span class="p">),</span>
                                <span class="n">var_sym</span><span class="p">,</span>
                                <span class="kt">Expr</span><span class="p">(</span><span class="o">:</span><span class="n">ref</span><span class="p">,</span> <span class="n">IN_TYPES</span><span class="p">,</span> <span class="n">idx_sym</span><span class="p">)</span>
                            <span class="p">)</span>
                        <span class="k">end</span>
                        <span class="n">field</span><span class="o">.</span><span class="n">var</span>
                    <span class="k">end</span>
            <span class="k">end</span>
        <span class="kt">Expr</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">args</span><span class="o">...</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kt">Expr</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">map</span><span class="p">(</span><span class="n">visit</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span><span class="o">...</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=&gt;</span> <span class="n">a</span>
    <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>You might not be able to understand what the meanings of <code class="docutils literal notranslate"><span class="pre">fields</span></code> and
<code class="docutils literal notranslate"><span class="pre">assigns</span></code> are, don’t worry too much, and I’m to explain it for you.</p>
<ul>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">fields</span> <span class="pre">:</span> <span class="pre">Dict{Any,</span> <span class="pre">Field}</span></code></p>
<p>Think about you want such a query <code class="docutils literal notranslate"><span class="pre">&#64;select</span> <span class="pre">_.foo</span> <span class="pre">*</span> <span class="pre">2,</span> <span class="pre">_.foo</span> <span class="pre">+</span> <span class="pre">2</span></code>,
you can see that field <code class="docutils literal notranslate"><span class="pre">foo</span></code> is referred twice, but you shouldn’t
make 2 symbols to represent the index of <code class="docutils literal notranslate"><span class="pre">foo</span></code> field. So I
introduce a dictionary <code class="docutils literal notranslate"><span class="pre">fields</span></code> here to avoid re-calculation.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">assigns</span> <span class="pre">:</span> <span class="pre">OrderedDict{Any,</span> <span class="pre">Expr}</span></code></p>
<p>When you want to bind the index of <code class="docutils literal notranslate"><span class="pre">foo</span></code> to a given symbol
<code class="docutils literal notranslate"><span class="pre">idx_of_foo</span></code>, you should set an expressison
<code class="docutils literal notranslate"><span class="pre">$findfirst(==(:foo),</span> <span class="pre">$IN_FIELDS)</span></code> to <code class="docutils literal notranslate"><span class="pre">assigns</span></code> on key
<code class="docutils literal notranslate"><span class="pre">idx_of_foo</span></code>. The reason why we don’t use a <code class="docutils literal notranslate"><span class="pre">Vector{Expr}</span></code> to
represent <code class="docutils literal notranslate"><span class="pre">assigns</span></code> is, we can avoid re-assignments in some
cases(you can find an instance in <code class="docutils literal notranslate"><span class="pre">generate_groupby</span></code>).</p>
<p>Finally, <code class="docutils literal notranslate"><span class="pre">assigns</span></code> would be generated to the binding section of a
<code class="docutils literal notranslate"><span class="pre">let</span></code> sentence.</p>
</li>
</ul>
<p>Now, following previous discussions, we can firstly implement the
easiest one, codegen method for <code class="docutils literal notranslate"><span class="pre">where</span></code> clause.</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="k">function</span> <span class="n">generate_where</span><span class="p">(</span><span class="n">args</span> <span class="o">::</span> <span class="kt">AbstractArray</span><span class="p">)</span>
    <span class="n">field_getted</span> <span class="o">=</span> <span class="kt">Dict</span><span class="p">{</span><span class="kt">Symbol</span><span class="p">,</span> <span class="kt">Symbol</span><span class="p">}()</span>
    <span class="n">assign</span>       <span class="o">::</span> <span class="kt">Vector</span><span class="p">{</span><span class="kt">Any</span><span class="p">}</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">visit</span> <span class="o">=</span> <span class="n">mk_visit</span><span class="p">(</span><span class="n">field_getted</span><span class="p">,</span> <span class="n">assign</span><span class="p">)</span>

    <span class="n">pred</span> <span class="o">=</span> <span class="n">foldl</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="kc">true</span><span class="p">)</span> <span class="k">do</span> <span class="n">last</span><span class="p">,</span> <span class="n">arg</span>
        <span class="n">boolean</span> <span class="o">=</span> <span class="n">visit</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">last</span> <span class="o">===</span> <span class="kc">true</span>
            <span class="n">boolean</span>
        <span class="k">else</span>
            <span class="kt">Expr</span><span class="p">(</span><span class="o">:&amp;&amp;</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">boolean</span><span class="p">)</span>
        <span class="k">end</span>
    <span class="k">end</span>

    <span class="c"># where expression generation</span>
    <span class="n">query_routine</span><span class="p">(</span>
        <span class="n">assign</span><span class="p">,</span>
        <span class="kt">Expr</span><span class="p">(</span><span class="o">:</span><span class="n">tuple</span><span class="p">,</span>
             <span class="n">IN_FIELDS</span><span class="p">,</span>
             <span class="n">TYPE</span><span class="p">,</span>
             <span class="o">:</span><span class="p">(</span><span class="o">$</span><span class="n">RECORD</span> <span class="k">for</span> <span class="o">$</span><span class="n">RECORD</span> <span class="kp">in</span> <span class="o">$</span><span class="n">SOURCE</span> <span class="k">if</span> <span class="o">$</span><span class="n">pred</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>
<span class="k">end</span>
</pre></div>
</div>
<p>Then <code class="docutils literal notranslate"><span class="pre">select</span></code>:</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="k">function</span> <span class="n">generate_select</span><span class="p">(</span><span class="n">args</span> <span class="o">::</span> <span class="kt">AbstractArray</span><span class="p">)</span>
    <span class="n">map_in_fields</span> <span class="o">=</span> <span class="kt">Dict</span><span class="p">{</span><span class="kt">Any</span><span class="p">,</span> <span class="n">Field</span><span class="p">}()</span>
    <span class="n">assigns</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">{</span><span class="kt">Symbol</span><span class="p">,</span> <span class="kt">Any</span><span class="p">}()</span>
    <span class="n">fn_return_elts</span>   <span class="o">::</span> <span class="kt">Vector</span><span class="p">{</span><span class="kt">Any</span><span class="p">}</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">fn_return_fields</span> <span class="o">::</span> <span class="kt">Vector</span><span class="p">{</span><span class="kt">Any</span><span class="p">}</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">visit</span> <span class="o">=</span> <span class="n">mk_visit</span><span class="p">(</span><span class="n">map_in_fields</span><span class="p">,</span> <span class="n">assigns</span><span class="p">)</span>
    <span class="c"># process selectors</span>
    <span class="n">predicate_process</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="o">=</span>
        <span class="nd">@match</span> <span class="n">arg</span> <span class="k">begin</span>
        <span class="o">:</span><span class="p">(</span><span class="o">!$</span><span class="n">pred</span><span class="p">(</span><span class="o">$</span> <span class="p">(</span><span class="n">args</span><span class="o">...</span><span class="p">)</span> <span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="n">Do</span><span class="p">(</span><span class="n">ab</span><span class="o">=</span><span class="kc">true</span><span class="p">)</span>  <span class="o">||</span>
        <span class="o">:</span><span class="p">(</span><span class="o">$</span><span class="n">pred</span><span class="p">(</span><span class="o">$</span> <span class="p">(</span><span class="n">args</span><span class="o">...</span><span class="p">)</span> <span class="p">))</span>  <span class="o">&amp;&amp;</span> <span class="n">Do</span><span class="p">(</span><span class="n">ab</span><span class="o">=</span><span class="kc">false</span><span class="p">)</span> <span class="o">||</span>
        <span class="o">:</span><span class="p">(</span><span class="o">!$</span><span class="n">pred</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">Do</span><span class="p">(</span><span class="n">ab</span><span class="o">=</span><span class="kc">true</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">[])</span>       <span class="o">||</span>
        <span class="o">:</span><span class="p">(</span><span class="o">$</span><span class="n">pred</span><span class="p">)</span>  <span class="o">&amp;&amp;</span> <span class="n">Do</span><span class="p">(</span><span class="n">ab</span><span class="o">=</span><span class="kc">false</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">[])</span>      <span class="o">=&gt;</span>
            <span class="k">let</span> <span class="n">idx_sym</span> <span class="o">=</span> <span class="n">gen_sym</span><span class="p">()</span>
                <span class="n">assigns</span><span class="p">[</span><span class="n">idx_sym</span><span class="p">]</span> <span class="o">=</span>
                    <span class="kt">Expr</span><span class="p">(</span>
                        <span class="o">:</span><span class="n">call</span><span class="p">,</span>
                        <span class="n">findall</span><span class="p">,</span>
                        <span class="n">ab</span> <span class="o">?</span>
                            <span class="o">:</span><span class="p">(</span><span class="nd">@inline</span> <span class="k">function</span> <span class="p">(</span><span class="o">$</span><span class="n">ARG</span><span class="p">,)</span> <span class="o">!$</span><span class="n">pred</span><span class="p">(</span><span class="o">$</span><span class="n">string</span><span class="p">(</span><span class="o">$</span><span class="n">ARG</span><span class="p">,),</span> <span class="o">$</span><span class="p">(</span><span class="n">args</span><span class="o">...</span><span class="p">))</span> <span class="k">end</span><span class="p">)</span> <span class="o">:</span>
                            <span class="o">:</span><span class="p">(</span><span class="nd">@inline</span> <span class="k">function</span> <span class="p">(</span><span class="o">$</span><span class="n">ARG</span><span class="p">,)</span> <span class="o">$</span><span class="n">pred</span><span class="p">(</span><span class="o">$</span><span class="n">string</span><span class="p">(</span><span class="o">$</span><span class="n">ARG</span><span class="p">,),</span> <span class="o">$</span><span class="p">(</span><span class="n">args</span><span class="o">...</span><span class="p">))</span> <span class="k">end</span><span class="p">)</span>
                        <span class="p">,</span> <span class="n">IN_FIELDS</span>
                    <span class="p">)</span>
                <span class="n">idx_sym</span>
            <span class="k">end</span>
        <span class="k">end</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">fn_return_elts</span></code> will be finally evaluated as the return of <code class="docutils literal notranslate"><span class="pre">FN</span></code>,
while <code class="docutils literal notranslate"><span class="pre">FN</span></code> will be used to be generate the next <code class="docutils literal notranslate"><span class="pre">IN_SOURCE</span></code> with
<code class="docutils literal notranslate"><span class="pre">:(let</span> <span class="pre">...</span> <span class="pre">;</span> <span class="pre">$FN($args...)</span> <span class="pre">end</span> <span class="pre">for</span> <span class="pre">$RECORD</span> <span class="pre">in</span> <span class="pre">$SOURCE)</span></code>, while
<code class="docutils literal notranslate"><span class="pre">fn_retrun_fields</span></code> will be finally used to generate the next
<code class="docutils literal notranslate"><span class="pre">IN_FIELDS</span></code> with <code class="docutils literal notranslate"><span class="pre">Expr(:vect,</span> <span class="pre">fn_return_fields...)</span></code>.</p>
<p>Let’s go ahead.</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">foreach</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="k">do</span> <span class="n">arg</span>
    <span class="nd">@match</span> <span class="n">arg</span> <span class="k">begin</span>
        <span class="o">:</span><span class="n">_</span> <span class="o">=&gt;</span>
            <span class="k">let</span> <span class="n">field</span> <span class="o">=</span> <span class="n">get!</span><span class="p">(</span><span class="n">map_in_fields</span><span class="p">,</span> <span class="n">all</span><span class="p">)</span> <span class="k">do</span>
                    <span class="n">var_sym</span> <span class="o">=</span> <span class="n">gen_sym</span><span class="p">()</span>
                    <span class="n">push!</span><span class="p">(</span><span class="n">fn_return_elts</span><span class="p">,</span> <span class="kt">Expr</span><span class="p">(</span><span class="o">:...</span><span class="p">,</span> <span class="n">var_sym</span><span class="p">))</span>
                    <span class="n">push!</span><span class="p">(</span><span class="n">fn_return_fields</span><span class="p">,</span> <span class="kt">Expr</span><span class="p">(</span><span class="o">:...</span><span class="p">,</span> <span class="n">IN_FIELDS</span><span class="p">))</span>
                    <span class="n">Field</span><span class="p">(</span>
                        <span class="n">all</span><span class="p">,</span>
                        <span class="n">RECORD</span><span class="p">,</span>
                        <span class="n">var_sym</span><span class="p">,</span>
                        <span class="o">:</span><span class="p">(</span><span class="o">$</span><span class="kt">Tuple</span><span class="p">{</span><span class="o">$</span><span class="n">IN_TYPES</span><span class="o">...</span><span class="p">})</span>
                    <span class="p">)</span>
                <span class="k">end</span>
                <span class="nb">nothing</span>
            <span class="k">end</span>
</pre></div>
</div>
<p>We’ve said that <code class="docutils literal notranslate"><span class="pre">&#64;select</span> <span class="pre">_</span></code> here is equivalent to <code class="docutils literal notranslate"><span class="pre">SELECT</span> <span class="pre">*</span></code> in
T-SQL.</p>
<p>The remaining is also implemented with a concise case splitting via
pattern matchings on ASTs.</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="o">:</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="p">(</span><span class="o">$</span><span class="p">(</span><span class="n">args</span><span class="o">...</span><span class="p">)))</span> <span class="o">=&gt;</span>
    <span class="k">let</span> <span class="n">indices</span> <span class="o">=</span> <span class="n">map</span><span class="p">(</span><span class="n">predicate_process</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">haskey</span><span class="p">(</span><span class="n">map_in_fields</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span>
            <span class="n">throw</span><span class="p">(</span><span class="s">&quot;The columns `</span><span class="si">$</span><span class="p">(</span><span class="n">string</span><span class="p">(</span><span class="n">arg</span><span class="p">))</span><span class="s">` are selected twice!&quot;</span><span class="p">)</span>
        <span class="k">elseif</span> <span class="o">!</span><span class="n">isempty</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
            <span class="n">idx_sym</span> <span class="o">=</span> <span class="n">gen_sym</span><span class="p">()</span>
            <span class="n">var_sym</span> <span class="o">=</span> <span class="n">gen_sym</span><span class="p">()</span>
            <span class="n">field</span> <span class="o">=</span> <span class="k">begin</span>
                <span class="n">assigns</span><span class="p">[</span><span class="n">idx_sym</span><span class="p">]</span> <span class="o">=</span>
                    <span class="n">length</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">===</span> <span class="mi">1</span> <span class="o">?</span>
                    <span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">:</span>
                    <span class="kt">Expr</span><span class="p">(</span><span class="o">:</span><span class="n">call</span><span class="p">,</span> <span class="n">intersect</span><span class="p">,</span> <span class="n">indices</span><span class="o">...</span><span class="p">)</span>
                <span class="n">push!</span><span class="p">(</span><span class="n">fn_return_elts</span><span class="p">,</span> <span class="kt">Expr</span><span class="p">(</span><span class="o">:...</span><span class="p">,</span> <span class="n">var_sym</span><span class="p">))</span>
                <span class="n">push!</span><span class="p">(</span><span class="n">fn_return_fields</span><span class="p">,</span> <span class="kt">Expr</span><span class="p">(</span><span class="o">:...</span><span class="p">,</span> <span class="kt">Expr</span><span class="p">(</span><span class="o">:</span><span class="n">ref</span><span class="p">,</span> <span class="n">IN_FIELDS</span><span class="p">,</span> <span class="n">idx_sym</span><span class="p">)))</span>
                <span class="n">Field</span><span class="p">(</span>
                    <span class="n">arg</span><span class="p">,</span>
                    <span class="kt">Expr</span><span class="p">(</span><span class="o">:</span><span class="n">ref</span><span class="p">,</span> <span class="n">RECORD</span><span class="p">,</span> <span class="n">idx_sym</span><span class="p">),</span>
                    <span class="n">var_sym</span><span class="p">,</span>
                    <span class="kt">Expr</span><span class="p">(</span><span class="o">:</span><span class="n">curly</span><span class="p">,</span> <span class="kt">Tuple</span><span class="p">,</span> <span class="kt">Expr</span><span class="p">(</span><span class="o">:...</span><span class="p">,</span> <span class="kt">Expr</span><span class="p">(</span><span class="o">:</span><span class="n">ref</span><span class="p">,</span> <span class="n">IN_TYPES</span><span class="p">,</span> <span class="n">idx_sym</span><span class="p">)))</span>
                <span class="p">)</span>
            <span class="k">end</span>
            <span class="n">map_in_fields</span><span class="p">[</span><span class="n">arg</span><span class="p">]</span> <span class="o">=</span> <span class="n">field</span>
            <span class="nb">nothing</span>
        <span class="k">end</span>
    <span class="k">end</span>
</pre></div>
</div>
<p>Above case is for handling with field filters, like
<code class="docutils literal notranslate"><span class="pre">&#64;select</span> <span class="pre">_.(!startswith(&quot;Java&quot;),</span> <span class="pre">endswith(&quot;#&quot;))</span></code>.</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span>           <span class="o">:</span><span class="p">(</span><span class="o">$</span><span class="n">a</span> <span class="o">=&gt;</span> <span class="o">$</span><span class="n">new_field</span><span class="p">)</span> <span class="o">||</span> <span class="n">a</span> <span class="o">&amp;&amp;</span> <span class="n">Do</span><span class="p">(</span><span class="n">new_field</span> <span class="o">=</span> <span class="kt">Symbol</span><span class="p">(</span><span class="n">string</span><span class="p">(</span><span class="n">a</span><span class="p">)))</span> <span class="o">=&gt;</span>
                <span class="k">let</span> <span class="n">new_value</span> <span class="o">=</span> <span class="n">visit</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
                    <span class="n">push!</span><span class="p">(</span><span class="n">fn_return_fields</span><span class="p">,</span> <span class="kt">QuoteNode</span><span class="p">(</span><span class="n">new_field</span><span class="p">))</span>
                    <span class="n">push!</span><span class="p">(</span><span class="n">fn_return_elts</span><span class="p">,</span> <span class="n">new_value</span><span class="p">)</span>
                    <span class="nb">nothing</span>
                <span class="k">end</span>
        <span class="k">end</span>
    <span class="k">end</span>

    <span class="n">fields</span> <span class="o">=</span> <span class="n">map_in_fields</span> <span class="o">|&gt;</span> <span class="n">values</span> <span class="o">|&gt;</span> <span class="n">collect</span>
    <span class="n">assigns</span><span class="p">[</span><span class="n">FN_OUT_FIELDS</span><span class="p">]</span> <span class="o">=</span> <span class="kt">Expr</span><span class="p">(</span><span class="o">:</span><span class="n">vect</span><span class="p">,</span> <span class="n">fn_return_fields</span><span class="o">...</span><span class="p">)</span>
    <span class="c"># select expression generation</span>
    <span class="n">query_routine</span><span class="p">(</span>
        <span class="n">assigns</span><span class="p">,</span>
        <span class="n">fields</span><span class="p">,</span>
        <span class="kt">Expr</span><span class="p">(</span><span class="o">:</span><span class="n">tuple</span><span class="p">,</span> <span class="n">fn_return_elts</span><span class="o">...</span><span class="p">),</span>
        <span class="kt">Expr</span><span class="p">(</span>
            <span class="o">:</span><span class="n">tuple</span><span class="p">,</span>
            <span class="n">FN_OUT_FIELDS</span><span class="p">,</span>
            <span class="n">FN_RETURN_TYPES</span><span class="p">,</span>
            <span class="o">:</span><span class="p">(</span><span class="o">$</span><span class="p">(</span><span class="n">fn_apply</span><span class="p">(</span><span class="n">fields</span><span class="p">))</span> <span class="k">for</span> <span class="o">$</span><span class="n">RECORD</span> <span class="kp">in</span> <span class="o">$</span><span class="n">IN_SOURCE</span><span class="p">)</span>
        <span class="p">);</span> <span class="n">infer_type</span> <span class="o">=</span> <span class="kc">true</span>
    <span class="p">)</span>
<span class="k">end</span>
</pre></div>
</div>
<p>Above case is for handling with regular expressions which might contain
something like <code class="docutils literal notranslate"><span class="pre">_.x</span></code>, <code class="docutils literal notranslate"><span class="pre">_.(1)</span></code> or <code class="docutils literal notranslate"><span class="pre">_.&quot;is</span> <span class="pre">ruby&quot;</span></code>.</p>
<p>Meanwhile, <code class="docutils literal notranslate"><span class="pre">=&gt;</span></code> allows you to alias the expression with the name you
prefer. Note that, in terms of <code class="docutils literal notranslate"><span class="pre">&#64;select</span> <span class="pre">(_.foo</span> <span class="pre">=&gt;</span> <span class="pre">:a)</span> <span class="pre">=&gt;</span> <span class="pre">a</span></code>, the first
<code class="docutils literal notranslate"><span class="pre">=&gt;</span></code> is a normal infix operator, which denotes the built-in object
<code class="docutils literal notranslate"><span class="pre">Pair</span></code>, but the second is <em>alias</em>.</p>
<p>If you have problems with <code class="docutils literal notranslate"><span class="pre">$</span></code> in AST patterns, just remember that,
inside a <code class="docutils literal notranslate"><span class="pre">quote</span> <span class="pre">...</span> <span class="pre">end</span></code> or <code class="docutils literal notranslate"><span class="pre">:(...)</span></code>, ASTs/Expressions are compared
by literal, except for <code class="docutils literal notranslate"><span class="pre">$(...)</span></code> things are matched via normal
patterns, for instance, <code class="docutils literal notranslate"><span class="pre">:($(a</span> <span class="pre">::</span> <span class="pre">Symbol)</span> <span class="pre">=</span> <span class="pre">1)</span></code> can match
<code class="docutils literal notranslate"><span class="pre">:($a</span> <span class="pre">=</span> <span class="pre">1)</span></code> if the available variable <code class="docutils literal notranslate"><span class="pre">a</span></code> has type <code class="docutils literal notranslate"><span class="pre">Symbol</span></code>.</p>
<p>With respect of <code class="docutils literal notranslate"><span class="pre">groupby</span></code> and <code class="docutils literal notranslate"><span class="pre">having</span></code>, they’re too long to put in
this article, so you might want to check them at
<a class="reference external" href="https://github.com/thautwarm/MLStyle-Playground/blob/master/MQuery/MQuery.Impl.jl#L217">MQuery.Impl.jl#L217</a>.</p>
</div>
<div class="section" id="enjoy-you-a-query-language">
<h2>Enjoy You A Query Language<a class="headerlink" href="#enjoy-you-a-query-language" title="Permalink to this headline">¶</a></h2>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">Enums</span>
<span class="nd">@enum</span> <span class="n">TypeChecking</span> <span class="n">Dynamic</span> <span class="n">Static</span>

<span class="n">include</span><span class="p">(</span><span class="s">&quot;MQuery.jl&quot;</span><span class="p">)</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">DataFrame</span><span class="p">(</span>
        <span class="kt">Symbol</span><span class="p">(</span><span class="s">&quot;Type checking&quot;</span><span class="p">)</span> <span class="o">=&gt;</span>
            <span class="p">[</span><span class="n">Dynamic</span><span class="p">,</span> <span class="n">Static</span><span class="p">,</span> <span class="n">Static</span><span class="p">,</span> <span class="n">Dynamic</span><span class="p">,</span> <span class="n">Static</span><span class="p">,</span> <span class="n">Dynamic</span><span class="p">,</span> <span class="n">Dynamic</span><span class="p">,</span> <span class="n">Static</span><span class="p">],</span>
        <span class="o">:</span><span class="n">name</span> <span class="o">=&gt;</span>
            <span class="p">[</span><span class="s">&quot;Julia&quot;</span><span class="p">,</span> <span class="s">&quot;C#&quot;</span><span class="p">,</span> <span class="s">&quot;F#&quot;</span><span class="p">,</span> <span class="s">&quot;Ruby&quot;</span><span class="p">,</span> <span class="s">&quot;Java&quot;</span><span class="p">,</span> <span class="s">&quot;JavaScript&quot;</span><span class="p">,</span> <span class="s">&quot;Python&quot;</span><span class="p">,</span> <span class="s">&quot;Haskell&quot;</span><span class="p">]),</span>
        <span class="o">:</span><span class="n">year</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="mi">2012</span><span class="p">,</span> <span class="mi">2000</span><span class="p">,</span> <span class="mi">2005</span><span class="p">,</span> <span class="mi">1995</span><span class="p">,</span> <span class="mi">1995</span><span class="p">,</span> <span class="mi">1995</span><span class="p">,</span> <span class="mi">1990</span><span class="p">,</span> <span class="mi">1990</span><span class="p">]</span>
<span class="p">)</span>

<span class="n">df</span> <span class="o">|&gt;</span>
<span class="nd">@where</span> <span class="o">!</span><span class="n">startswith</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;Java&quot;</span><span class="p">),</span>
<span class="nd">@groupby</span> <span class="n">_</span><span class="o">.</span><span class="s">&quot;Type checking&quot;</span> <span class="o">=&gt;</span> <span class="n">TC</span><span class="p">,</span> <span class="n">endswith</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;#&quot;</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">is_sharp</span><span class="p">,</span>
<span class="nd">@having</span> <span class="n">TC</span> <span class="o">===</span> <span class="n">Dynamic</span> <span class="o">||</span> <span class="n">is_sharp</span><span class="p">,</span>
<span class="nd">@select</span> <span class="n">join</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot; and &quot;</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">result</span><span class="p">,</span> <span class="n">_</span><span class="o">.</span><span class="n">TC</span> <span class="o">=&gt;</span> <span class="n">TC</span>
</pre></div>
</div>
<p>outputs</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>2×2 DataFrame
│ Row │ result                    │ TC        │
│     │ String                    │ TypeChec… │
├─────┼───────────────────────────┼───────────┤
│ 1   │ Julia and Ruby and Python │ Dynamic   │
│ 2   │ C# and F#                 │ Static    │
</pre></div>
</div>
</div>
</div>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
<div id="sourcelink">
  <a href="../_sources/DSL/write-your-a-query-language-with-MLStyle.rst.txt"
     rel="nofollow">Source</a>
</div>
      
    </p>
    <p>
        &copy; Copyright 2020, thautwarm.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.0.<br/>
    </p>
  </div>
</footer>
  </body>
</html>