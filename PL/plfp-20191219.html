<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
        <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Tagless Final For Writing Compilers &#8212; thautwarm&#39;s blog pages</title>
    <link rel="stylesheet" href="../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Julia Counts for PL Researchers" href="elaborating-julia.html" />
    <link rel="prev" title="FSYM: An Abstraction On Tagless-Final Style To Compositing And Decoupling Multiple Interpretations" href="plfp-20191212.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../_static/js/jquery-1.11.0.min.js "></script>
<script type="text/javascript" src="../_static/js/jquery-fix.js "></script>
<script type="text/javascript" src="../_static/bootstrap-3.3.7/js/bootstrap.min.js "></script>
<script type="text/javascript" src="../_static/bootstrap-sphinx.js "></script>

  </head><body>

  <div id="navbar" class="navbar navbar-inverse navbar-default ">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../guide.html">
          Site-32</a>
        <span class="navbar-text navbar-version pull-left"><b></b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="https://github.com/thautwarm">GitHub</a></li>
                <li><a href="index.html">PL</a></li>
                <li><a href="../Design/index.html">Design</a></li>
                <li><a href="../DSL/index.html">DSL</a></li>
                <li><a href="../Fiction/index.html">Fiction</a></li>
                <li><a href="../Others/index.html">Others</a></li>
                <li><a href="../Backup/index.html">Backup</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../guide.html">Site-32 <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../index.html">Site-32 Considered Harmful</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Compiler/index.html">Compiler</a><ul class="simple">
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../Design/index.html">Design</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../Design/General-Programming-In-Julia-Language-From-An-Advanced-Standpoint.html">General Programming In Julia Language From An Advanced Standpoint</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../Design/General-Programming-In-Julia-Language-From-An-Advanced-Standpoint.html#first-class">First-Class</a></li>
<li class="toctree-l3"><a class="reference internal" href="../Design/General-Programming-In-Julia-Language-From-An-Advanced-Standpoint.html#polymorphisms-of-multiple-dispatch">Polymorphisms of Multiple Dispatch</a></li>
<li class="toctree-l3"><a class="reference internal" href="../Design/General-Programming-In-Julia-Language-From-An-Advanced-Standpoint.html#full-featured-macros">Full-Featured Macros</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../Design/General-Programming-In-Julia-Language-From-An-Advanced-Standpoint.html#macro-the-function-from-ast-to-ast">Macro, the Function from AST to AST</a></li>
<li class="toctree-l4"><a class="reference internal" href="../Design/General-Programming-In-Julia-Language-From-An-Advanced-Standpoint.html#scope-and-hygiene">Scope and Hygiene</a></li>
<li class="toctree-l4"><a class="reference internal" href="../Design/General-Programming-In-Julia-Language-From-An-Advanced-Standpoint.html#other-useful-knowledge-for-julia-macros">Other Useful Knowledge for Julia Macros</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../Design/General-Programming-In-Julia-Language-From-An-Advanced-Standpoint.html#a-big-step-forward-in-ast-manipulations">A Big Step Forward in AST Manipulations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../Design/General-Programming-In-Julia-Language-From-An-Advanced-Standpoint.html#limitation-absence-of-function-types">Limitation: Absence of Function Types</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../Design/Some-Thoughts-About-The-RestrainJIT.html">Some Thoughts About The Restrain JIT</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Design/Research-Restrain-JIT.html">Research: Review and Observations of Python JIT</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../Design/Research-Restrain-JIT.html#history">History</a></li>
<li class="toctree-l3"><a class="reference internal" href="../Design/Research-Restrain-JIT.html#observations">Observations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../Design/PEP622-1.html">My Comments about PEP 622(V1)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../Design/PEP622-1.html#my-concerns">My Concerns</a></li>
<li class="toctree-l3"><a class="reference internal" href="../Design/PEP622-1.html#scoping-issues">Scoping Issues</a></li>
<li class="toctree-l3"><a class="reference internal" href="../Design/PEP622-1.html#comments-about-the-rejection-of-and-patterns">Comments about the rejection of AND (&amp;) patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="../Design/PEP622-1.html#consider-performance-guards-as-patterns">Consider Performance: Guards As Patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="../Design/PEP622-1.html#grammar-change-feature-request-parameterized-patterns">Grammar Change &amp; Feature Request: Parameterized Patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="../Design/PEP622-1.html#an-alternative-match-protocol-can-be-better-in-simplicity-efficiency-and-expressivity">An Alternative <code class="docutils literal notranslate"><span class="pre">__match__</span></code> Protocol Can be Better in Simplicity, Efficiency, and Expressivity.</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../Design/PEP622-1.html#simplicity-of-the-alternative-match-protocol">Simplicity of the alternative <code class="docutils literal notranslate"><span class="pre">__match__</span></code> protocol</a></li>
<li class="toctree-l4"><a class="reference internal" href="../Design/PEP622-1.html#the-alternative-match-protocol-is-efficient">The alternative <code class="docutils literal notranslate"><span class="pre">__match__</span></code> protocol is efficient</a></li>
<li class="toctree-l4"><a class="reference internal" href="../Design/PEP622-1.html#the-alternative-match-protocol-results-in-better-expressivity">The alternative <code class="docutils literal notranslate"><span class="pre">__match__</span></code> protocol results in better expressivity</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../Design/PEP622-1.html#miscellaneous">Miscellaneous</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../Design/PEP622-1.html#else-clauses-in-pattern-matching"><code class="docutils literal notranslate"><span class="pre">else</span></code> Clauses in Pattern Matching</a></li>
<li class="toctree-l4"><a class="reference internal" href="../Design/PEP622-1.html#grammar-of-patterns-could-become-that-of-expressions">Grammar of Patterns Could Become That of Expressions</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../Design/PEP622-2.html">PEP 622(V2)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../Design/PEP622-2.html#bringing-else-back-is-rejected">Bringing <code class="docutils literal notranslate"><span class="pre">else</span></code> Back is Rejected</a></li>
<li class="toctree-l3"><a class="reference internal" href="../Design/PEP622-2.html#variables-in-patterns-bindings-instead-of-evaluations-and-comparisons">Variables in Patterns: Bindings instead of Evaluations and Comparisons</a></li>
<li class="toctree-l3"><a class="reference internal" href="../Design/PEP622-2.html#alternative-match-protocol">Alternative <code class="docutils literal notranslate"><span class="pre">__match__</span></code> Protocol</a></li>
<li class="toctree-l3"><a class="reference internal" href="../Design/PEP622-2.html#the-switch-semantics">The Switch Semantics</a></li>
<li class="toctree-l3"><a class="reference internal" href="../Design/PEP622-2.html#scope">Scope</a></li>
<li class="toctree-l3"><a class="reference internal" href="../Design/PEP622-2.html#miscellaneous">Miscellaneous</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../DSL/index.html">DSL</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../DSL/write-your-a-query-language-with-MLStyle.html">Write You A Query Language</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../DSL/write-your-a-query-language-with-MLStyle.html#definition-of-syntaxes">Definition of Syntaxes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../DSL/write-your-a-query-language-with-MLStyle.html#codegen-target">Codegen Target</a></li>
<li class="toctree-l3"><a class="reference internal" href="../DSL/write-your-a-query-language-with-MLStyle.html#refinement-of-codegen-typed-columns">Refinement of Codegen: Typed Columns</a></li>
<li class="toctree-l3"><a class="reference internal" href="../DSL/write-your-a-query-language-with-MLStyle.html#implementation">Implementation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../DSL/write-your-a-query-language-with-MLStyle.html#enjoy-you-a-query-language">Enjoy You A Query Language</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../Fiction/index.html">Fiction</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../Fiction/index.html#id1">2021年4月</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Fiction/index.html#id3">2020年10月</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Fiction/index.html#id4">2020年6月</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Fiction/index.html#id7">2020年4月</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Fiction/index.html#id9">2019年10月</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../Fiction/index.html#id10">日前安排</a></li>
<li class="toctree-l3"><a class="reference internal" href="../Fiction/index.html#id18">目录</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../Fiction/日记2019-10-13.html">Smarter Witnesses for Type Classes</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../Fiction/日记2019-10-13.html#notation">Notation</a></li>
<li class="toctree-l5"><a class="reference internal" href="../Fiction/日记2019-10-13.html#instance-resolution-variables-as-instances">Instance Resolution &amp; Variables As Instances</a></li>
<li class="toctree-l5"><a class="reference internal" href="../Fiction/日记2019-10-13.html#the-most-general-instance-problem-overlapping-instance-problem">“The Most General Instance” Problem &amp; “Overlapping Instance” Problem</a></li>
<li class="toctree-l5"><a class="reference internal" href="../Fiction/日记2019-10-13.html#id1">优化</a></li>
<li class="toctree-l5"><a class="reference internal" href="../Fiction/日记2019-10-13.html#id2">该算法和相应语言设计的好处</a></li>
<li class="toctree-l5"><a class="reference internal" href="../Fiction/日记2019-10-13.html#id3">不足之处</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../Fiction/日记2019-10-15.html">我和Python的故事</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../Fiction/日记2019-10-15.html#id1">第0节</a></li>
<li class="toctree-l5"><a class="reference internal" href="../Fiction/日记2019-10-15.html#id2">第1节: 科学计算, Python, 生物信息学和数据挖掘</a></li>
<li class="toctree-l5"><a class="reference internal" href="../Fiction/日记2019-10-15.html#id3">第2节: 转型的经过, 走向程序语言设计领域</a></li>
<li class="toctree-l5"><a class="reference internal" href="../Fiction/日记2019-10-15.html#id4">第3节: 想要给Python添加高级语言特性的理想</a></li>
<li class="toctree-l5"><a class="reference internal" href="../Fiction/日记2019-10-15.html#id5">第4节: Flowpython</a></li>
<li class="toctree-l5"><a class="reference internal" href="../Fiction/日记2019-10-15.html#bnf-parser-generator">第4节: BNF, Parser Generator和语言制造机器</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../Fiction/日记2019-10-30.html">杂谈</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../Fiction/日记2019-10-30.html#pycon-china-2019">PyCon China 2019 成都</a></li>
<li class="toctree-l5"><a class="reference internal" href="../Fiction/日记2019-10-30.html#id2">直面自己的人格缺陷</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../Fiction/日记2019-11-06.html">杂谈</a></li>
<li class="toctree-l4"><a class="reference internal" href="../Fiction/日记2019-11-14.html">我太难了</a></li>
<li class="toctree-l4"><a class="reference internal" href="../Fiction/日记2019-11-17.html">我太懂了</a></li>
<li class="toctree-l4"><a class="reference internal" href="../Fiction/日记2020-01-07.html">打通</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../Fiction/日记2020-01-07.html#parsing">Parsing</a></li>
<li class="toctree-l5"><a class="reference internal" href="../Fiction/日记2020-01-07.html#python">Python 字节码</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../Fiction/日记2020-02-02.html">Tagless Final in F#</a></li>
<li class="toctree-l4"><a class="reference internal" href="../Fiction/日记2020-02-07.html">Encoding Typeclass Default Methods in Purescript</a></li>
<li class="toctree-l4"><a class="reference internal" href="../Fiction/日记2020-02-11.html">近期规划</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../Fiction/日记2020-02-11.html#purescript-python">Purescript-Python</a><ul>
<li class="toctree-l6"><a class="reference internal" href="../Fiction/日记2020-02-11.html#anf">从表达式优先到语句优先: ANF变换</a></li>
<li class="toctree-l6"><a class="reference internal" href="../Fiction/日记2020-02-11.html#pythonfirst-class">Python虚拟机上的First-class的表达式优先</a></li>
<li class="toctree-l6"><a class="reference internal" href="../Fiction/日记2020-02-11.html#id2">社区意见</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../Fiction/cure/和平日久.html">如何写出令人感到幸福的小说</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../Fiction/cure/和平日久.html#id2">合理利用“无敌”元素</a></li>
<li class="toctree-l5"><a class="reference internal" href="../Fiction/cure/和平日久.html#id3">“纯爱”而非“后宫”</a></li>
<li class="toctree-l5"><a class="reference internal" href="../Fiction/cure/和平日久.html#id4">细腻的画面感</a></li>
<li class="toctree-l5"><a class="reference internal" href="../Fiction/cure/和平日久.html#id5">节奏流畅的回忆</a></li>
<li class="toctree-l5"><a class="reference internal" href="../Fiction/cure/和平日久.html#id6">暗线和潜台词</a></li>
<li class="toctree-l5"><a class="reference internal" href="../Fiction/cure/和平日久.html#id7">总结</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../Fiction/cure/乐理菜鸡怎么给自己的小说写bgm.html">乐理菜鸡怎么给自己的小说写BGM?</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../Fiction/cure/乐理菜鸡怎么给自己的小说写bgm.html#id1">找调</a></li>
<li class="toctree-l5"><a class="reference internal" href="../Fiction/cure/乐理菜鸡怎么给自己的小说写bgm.html#id2">打谱</a></li>
<li class="toctree-l5"><a class="reference internal" href="../Fiction/cure/乐理菜鸡怎么给自己的小说写bgm.html#id3">总结</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Programming Language</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="HKT.html">Higher Kinded Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="typeclass.html">Type Classes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="typeclass.html#about-abstractions">About Abstractions</a></li>
<li class="toctree-l3"><a class="reference internal" href="typeclass.html#about-separation-of-type-definitions-and-data-manipulations">About Separation of Type Definitions and Data Manipulations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="paper-reading-LHKP.html">Paper Reading: Lightweight-Higher-Kinded-Polymorphism</a><ul>
<li class="toctree-l3"><a class="reference internal" href="paper-reading-LHKP.html#how-to">How-To</a></li>
<li class="toctree-l3"><a class="reference internal" href="paper-reading-LHKP.html#static-resolution-more-polymorphic">Static Resolution: More polymorphic</a></li>
<li class="toctree-l3"><a class="reference internal" href="paper-reading-LHKP.html#limitation1-much-higher-kinded">Limitation1: Much Higher Kinded</a></li>
<li class="toctree-l3"><a class="reference internal" href="paper-reading-LHKP.html#limitation2-identity">Limitation2: Identity</a></li>
<li class="toctree-l3"><a class="reference internal" href="paper-reading-LHKP.html#why-this-lightweight-higher-polymorphism-instead-of-the-haskell-approach">Why this Lightweight-Higher-Polymorphism instead of the Haskell approach</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="HKT-typeclass-FSharp.html">Compelling Higher Kinded Types and Type Classes in F#</a><ul>
<li class="toctree-l3"><a class="reference internal" href="HKT-typeclass-FSharp.html#active-pattern">Active Pattern</a></li>
<li class="toctree-l3"><a class="reference internal" href="HKT-typeclass-FSharp.html#statically-resolved-type-parameters">Statically Resolved Type Parameters</a></li>
<li class="toctree-l3"><a class="reference internal" href="HKT-typeclass-FSharp.html#the-getsig-function-and-implicits">The <em>getsig</em> Function and Implicits</a></li>
<li class="toctree-l3"><a class="reference internal" href="HKT-typeclass-FSharp.html#why-abstractclass">Why AbstractClass?</a></li>
<li class="toctree-l3"><a class="reference internal" href="HKT-typeclass-FSharp.html#why-functor-f-instead-of-the-straightforward-functor">Why <em>Functor&lt;’F&gt;</em> instead of the straightforward <em>Functor</em></a></li>
<li class="toctree-l3"><a class="reference internal" href="HKT-typeclass-FSharp.html#references-and-further-reading">References and Further Reading</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="plfp-20191212.html">FSYM: An Abstraction On Tagless-Final Style To Compositing And Decoupling Multiple Interpretations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="plfp-20191212.html#terminology">Terminology</a></li>
<li class="toctree-l3"><a class="reference internal" href="plfp-20191212.html#background">Background</a></li>
<li class="toctree-l3"><a class="reference internal" href="plfp-20191212.html#introduction">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="plfp-20191212.html#application">Application</a><ul>
<li class="toctree-l4"><a class="reference internal" href="plfp-20191212.html#scoping-name-resolution">Scoping: Name Resolution</a></li>
<li class="toctree-l4"><a class="reference internal" href="plfp-20191212.html#typing-type-inference">Typing: Type Inference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="plfp-20191212.html#references">References</a></li>
</ul>
</li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Tagless Final For Writing Compilers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#problem">Problem</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tagless-final-for-compiler-phases">Tagless Final For Compiler Phases</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#quick-start-for-tagless-final">Quick Start for Tagless Final</a></li>
<li class="toctree-l4"><a class="reference internal" href="#grammar">“Grammar”</a></li>
<li class="toctree-l4"><a class="reference internal" href="#expanding-representation">Expanding Representation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#problems-of-decoupling-and-compositing">Problems of Decoupling and Compositing</a></li>
<li class="toctree-l4"><a class="reference internal" href="#fsym">FSYM</a></li>
<li class="toctree-l4"><a class="reference internal" href="#laziness-for-mutual-dependencies">Laziness, for Mutual Dependencies</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#example">Example</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="elaborating-julia.html">Julia Counts for PL Researchers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="elaborating-julia.html#expressiveness">Expressiveness</a></li>
<li class="toctree-l3"><a class="reference internal" href="elaborating-julia.html#staging">Staging</a></li>
<li class="toctree-l3"><a class="reference internal" href="elaborating-julia.html#advantages-as-a-codegen-backend">Advantages as a codegen backend</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="tagless-final-pattern-match.html">First-class Pattern Matching in the Final Approach</a><ul>
<li class="toctree-l3"><a class="reference internal" href="tagless-final-pattern-match.html#core-ideas">Core Ideas</a></li>
<li class="toctree-l3"><a class="reference internal" href="tagless-final-pattern-match.html#full-implementation-in-haskell">Full implementation in Haskell</a></li>
<li class="toctree-l3"><a class="reference internal" href="tagless-final-pattern-match.html#enhancement-1">Enhancement 1</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="tagless-final-for-julia.html">Julia Benefits from Tagless Final</a><ul>
<li class="toctree-l3"><a class="reference internal" href="tagless-final-for-julia.html#what-happened-today">What Happened Today?</a></li>
<li class="toctree-l3"><a class="reference internal" href="tagless-final-for-julia.html#an-example-turns-out-to-be-type-unstable">An Example Turns Out to be Type Unstable</a></li>
<li class="toctree-l3"><a class="reference internal" href="tagless-final-for-julia.html#tagless-final-encoding-about-above-code">Tagless Final Encoding about Above Code</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="hrt-use-case.html">Some Use Cases for Higher Rank Polymorphisms(No Monad)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="hrt-use-case.html#polymorphic-functions-for-edsl">Polymorphic Functions for eDSL</a></li>
<li class="toctree-l3"><a class="reference internal" href="hrt-use-case.html#existential-types">Existential Types</a></li>
<li class="toctree-l3"><a class="reference internal" href="hrt-use-case.html#manipulation-for-heterogeneous-data">Manipulation for Heterogeneous Data</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../Backup/index.html">Backup</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../Backup/高观点下的Julia泛用编程.html">高观点下的Julia泛用编程</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../Others/index.html">Others</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../Others/contributions.html">Thautwarm’s Open Source Contributions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../Others/contributions.html#projects-owned-by-other-individuals-organizations">Projects Owned By Other Individuals/Organizations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../Others/contributions.html#leading-projects">Leading Projects</a></li>
<li class="toctree-l3"><a class="reference internal" href="../Others/contributions.html#other-notable-personal-projects">Other Notable Personal Projects</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Subsections <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">Tagless Final For Writing Compilers</a><ul>
<li><a class="reference internal" href="#problem">Problem</a></li>
<li><a class="reference internal" href="#tagless-final-for-compiler-phases">Tagless Final For Compiler Phases</a><ul>
<li><a class="reference internal" href="#quick-start-for-tagless-final">Quick Start for Tagless Final</a></li>
<li><a class="reference internal" href="#grammar">“Grammar”</a></li>
<li><a class="reference internal" href="#expanding-representation">Expanding Representation</a></li>
<li><a class="reference internal" href="#problems-of-decoupling-and-compositing">Problems of Decoupling and Compositing</a></li>
<li><a class="reference internal" href="#fsym">FSYM</a></li>
<li><a class="reference internal" href="#laziness-for-mutual-dependencies">Laziness, for Mutual Dependencies</a></li>
</ul>
</li>
<li><a class="reference internal" href="#example">Example</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <div class="section" id="tagless-final-for-writing-compilers">
<h1>Tagless Final For Writing Compilers<a class="headerlink" href="#tagless-final-for-writing-compilers" title="Permalink to this headline">¶</a></h1>
<p>Writing a compiler could consist of numerous steps.</p>
<p>Therefore, a solution to allow compiler writers to</p>
<ul class="simple">
<li>merely focus on only one step of the whole compilation at one time,</li>
<li>keep away from awaring other dependent steps, and</li>
<li>able to composite the separate steps into a big one,</li>
</ul>
<p>could be beneficial(better for collaborations as well?).</p>
<p>Tagless Final can be an approach for this demand, due to one of its useful feature:
“interpreting one term from various perspectives”.</p>
<div class="section" id="problem">
<h2>Problem<a class="headerlink" href="#problem" title="Permalink to this headline">¶</a></h2>
<p>Given a BNF grammar(hereafter as <code class="docutils literal notranslate"><span class="pre">Lamu0</span></code>),</p>
<div class="highlight-BNF notranslate"><div class="highlight"><pre><span></span>expr <span class="o">::=</span> let | lam | app
let  <span class="o">::=</span> &#39;let&#39; ID &#39;=&#39; expr &#39;in&#39; expr
lam  <span class="o">::=</span> &#39;fn&#39; ID &#39;=&gt;&#39; expr
app  <span class="o">::=</span> atomexpr
     |   app atomexpr
atomexpr <span class="o">::=</span> INT | STRING | FLOAT | &#39;(&#39; expr &#39;)&#39;
</pre></div>
</div>
<p>To compile the language <code class="docutils literal notranslate"><span class="pre">Lamu0</span></code> to a lower representation(like C),
there’re quite a lot of phases we have to go through, even though we don’t take GC or optimizations into consideration here:</p>
<ul>
<li><p class="first">To generate low level code, we shall</p>
<ul class="simple">
<li>check validity of program: type inference</li>
<li>eliminate high level language constructs like:<ul>
<li>lambda</li>
<li>name shadowing(let binding)</li>
<li>closure(free variables)</li>
</ul>
</li>
</ul>
</li>
<li><p class="first">To perform type inference</p>
<p>we’re supposed to correctly identify different occurrences for a symbol, and assign the same type to the symbol’s occurrences.</p>
</li>
<li><p class="first">To eliminate name shadowings</p>
<p>we’re supposed to rename duplicate symbols to make all of them unique.</p>
</li>
<li><p class="first">To eliminate closures, we do closure conversions</p>
<p>we’re supposed to find free variables for each lambda, and do some
extra code generation such as creating closure data structures.</p>
<p>note, we’re supposed to design the data structures to represent closures,
and different free variables might be stored using different low level
representations. So we need type inference.</p>
<p><code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">inference</span> <span class="pre">&lt;</span> <span class="pre">closure</span> <span class="pre">conversion</span></code></p>
</li>
<li><p class="first">To eliminate lambdas</p>
<p>we’re supposed to recursively lift lambdas to global functions, but any free variable shall be rejected here, thus this phase should start after closure conversions.</p>
<p><code class="docutils literal notranslate"><span class="pre">closure</span> <span class="pre">conversion</span> <span class="pre">&lt;</span> <span class="pre">eliminating</span> <span class="pre">lambdas</span></code></p>
</li>
</ul>
<p>Distinguishing scoped symbols from each other, detecting free variables, both of them
are involved in the analysis for <a class="reference external" href="https://en.wikipedia.org/wiki/Scope_(computer_science)"><strong>Scope</strong></a>s, or <a class="reference external" href="https://en.wikipedia.org/wiki/Name_resolution_(programming_languages)">name resolution</a>, thus</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">name</span> <span class="n">resolution</span> <span class="o">&lt;</span> <span class="nb">type</span> <span class="n">inference</span>

<span class="n">name</span> <span class="n">resolution</span> <span class="o">&lt;</span> <span class="n">eliminating</span> <span class="n">name</span> <span class="n">shadowing</span>

<span class="n">name</span> <span class="n">resolution</span> <span class="o">&lt;</span> <span class="n">closure</span> <span class="n">conversion</span>
</pre></div>
</div>
<p>Next, we can make a order for compiler phases, from source code to low level code:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">name</span> <span class="n">resolution</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>    <span class="o">&lt;</span> <span class="nb">type</span> <span class="n">infer</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">name</span> <span class="n">resolution</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>    <span class="o">&lt;</span> <span class="n">eliminating</span> <span class="n">name</span> <span class="n">shadowing</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">name</span> <span class="n">resolution</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>    <span class="o">&lt;</span> <span class="n">closure</span> <span class="n">conversion</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="nb">type</span> <span class="n">infer</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>         <span class="o">&lt;</span> <span class="n">closure</span> <span class="n">conversion</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="n">closure</span> <span class="n">conversion</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">eliminating</span> <span class="n">lambdas</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>One solution for these compiler phases is</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mf">1.</span> <span class="n">name</span> <span class="n">resolution</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>     <span class="o">&lt;</span>
<span class="mf">2.</span> <span class="nb">type</span> <span class="n">infer</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>          <span class="o">&lt;</span>
<span class="mf">3.</span> <span class="n">closure</span> <span class="n">conversion</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>  <span class="o">&lt;</span>
<span class="mf">4.</span> <span class="n">elim</span> <span class="n">lambdas</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>        <span class="o">&lt;</span>
<span class="mf">5.</span> <span class="n">elim</span> <span class="n">name</span> <span class="n">shadowing</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>Recall our goals:</p>
<ol class="simple">
<li>allow compiler writers to focus on only one phase, and no need to care about the
dependent phases(e.g., when writing type inference, no need to care about name resolution)</li>
<li>the separately implemented compiler phases can be composited into a big one</li>
</ol>
<p>We can use an example to illustrate the obstacles. Check following inference rule:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">LET</span><span class="p">:</span>
     <span class="n">A</span> <span class="o">|-</span> <span class="n">e</span><span class="p">:</span> \<span class="n">sigma</span>  <span class="n">A_x</span> \<span class="n">cup</span> <span class="p">{</span><span class="n">x</span> <span class="p">:</span> \<span class="n">sigma</span><span class="p">}</span> <span class="o">|-</span> <span class="n">e</span><span class="s1">&#39; : </span><span class="se">\t</span><span class="s1">au</span>
     <span class="o">----------------------------------------------------</span>
          <span class="n">A</span> <span class="o">|-</span> <span class="p">(</span><span class="n">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">e</span><span class="s1">&#39;) : </span><span class="se">\t</span><span class="s1">au</span>
</pre></div>
</div>
<p>In this case, I’d ask, what’s the form of the type environment <code class="docutils literal notranslate"><span class="pre">A</span></code>?</p>
<p>This might be considered trivial in many cases, but is crucial in my concerns.</p>
<p>Of course, we can maintain a map from <code class="docutils literal notranslate"><span class="pre">string</span></code> to <code class="docutils literal notranslate"><span class="pre">type</span></code>, and push and pop <code class="docutils literal notranslate"><span class="pre">string</span></code>-<code class="docutils literal notranslate"><span class="pre">type</span></code> pairs when inferencing.</p>
<p>However, it’d be beneficial if we have already transformed the symbols
(like <code class="docutils literal notranslate"><span class="pre">x</span></code> in <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">e</span> <span class="pre">in</span> <span class="pre">e'</span></code>) into unique ones, which will then make <code class="docutils literal notranslate"><span class="pre">A_x</span> <span class="pre">\cup</span> <span class="pre">{x:</span> <span class="pre">\sigma}</span></code> unnecessary,
and the inference becomes:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">LET</span><span class="p">:</span>
          <span class="n">A</span> <span class="o">|-</span> <span class="n">e</span><span class="p">:</span> \<span class="n">sigma</span>  <span class="n">A</span> <span class="o">|-</span> <span class="n">e</span><span class="s1">&#39; : </span><span class="se">\t</span><span class="s1">au</span>
     <span class="o">---------------------------------------</span>
          <span class="n">A</span> <span class="o">|-</span> <span class="p">(</span><span class="n">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">e</span><span class="s1">&#39;) : </span><span class="se">\t</span><span class="s1">au</span>
</pre></div>
</div>
<p>In this way, the overlap between name resolution and type inference gets eliminated. Further, operations like pushing and popping names are already done during name resolution, we don’t have to repeat it. We do dependent phases separately, things get decoupled.</p>
<p>However, the problem comes: How can we make sure the separately implemented compiler phases can get composited?</p>
</div>
<div class="section" id="tagless-final-for-compiler-phases">
<h2>Tagless Final For Compiler Phases<a class="headerlink" href="#tagless-final-for-compiler-phases" title="Permalink to this headline">¶</a></h2>
<div class="section" id="quick-start-for-tagless-final">
<h3>Quick Start for Tagless Final<a class="headerlink" href="#quick-start-for-tagless-final" title="Permalink to this headline">¶</a></h3>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">module</span> <span class="k">type</span> <span class="nc">SYM</span> <span class="o">=</span> <span class="k">sig</span>
   <span class="k">type</span> <span class="n">repr</span>
   <span class="k">val</span> <span class="n">zero</span><span class="o">:</span> <span class="n">repr</span>
   <span class="k">val</span> <span class="n">succ</span><span class="o">:</span> <span class="n">repr</span> <span class="o">-&gt;</span> <span class="n">repr</span>
<span class="k">end</span>

<span class="c">(* we want: pass in a module, get a new interpretation *)</span>

<span class="k">module</span> <span class="nc">SYMSelf</span> <span class="o">=</span> <span class="k">struct</span>
   <span class="k">type</span> <span class="n">repr</span> <span class="o">=</span> <span class="o">{</span><span class="n">e</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span><span class="o">.</span> <span class="o">(</span><span class="k">module</span> <span class="nc">SYM</span> <span class="k">with</span> <span class="k">type</span> <span class="n">repr</span> <span class="o">=</span> <span class="k">&#39;</span><span class="n">a</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="n">a</span><span class="o">}</span>
   <span class="k">let</span> <span class="n">zero</span> <span class="o">=</span> <span class="o">{</span><span class="n">e</span> <span class="o">=</span> <span class="k">fun</span> <span class="o">(</span><span class="k">type</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="k">module</span> <span class="nc">M</span><span class="o">:</span> <span class="nc">SYM</span> <span class="k">with</span> <span class="k">type</span> <span class="n">repr</span><span class="o">=</span><span class="n">a</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nn">M</span><span class="p">.</span><span class="n">zero</span><span class="o">}</span>
   <span class="k">let</span> <span class="n">succ</span> <span class="o">{</span><span class="n">e</span><span class="o">}</span> <span class="o">=</span> <span class="o">{</span><span class="n">e</span> <span class="o">=</span> <span class="k">fun</span> <span class="o">(</span><span class="k">type</span> <span class="n">a</span><span class="o">)</span> <span class="o">((</span><span class="k">module</span> <span class="nc">M</span><span class="o">:</span> <span class="nc">SYM</span> <span class="k">with</span> <span class="k">type</span> <span class="n">repr</span><span class="o">=</span><span class="n">a</span><span class="o">)</span> <span class="k">as</span> <span class="n">m</span><span class="o">)-&gt;</span> <span class="nn">M</span><span class="p">.</span><span class="n">succ</span> <span class="o">(</span><span class="n">e</span> <span class="n">m</span><span class="o">)}</span>
<span class="k">end</span>

<span class="k">let</span> <span class="n">run</span> <span class="o">(</span><span class="k">type</span> <span class="n">a</span><span class="o">)</span> <span class="o">((</span><span class="k">module</span> <span class="nc">M</span><span class="o">:</span> <span class="nc">SYM</span> <span class="k">with</span> <span class="k">type</span> <span class="n">repr</span><span class="o">=</span><span class="n">a</span><span class="o">)</span> <span class="k">as</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="nn">SYMSelf</span><span class="p">.</span><span class="o">({</span><span class="n">e</span><span class="o">}))</span> <span class="o">=</span> <span class="n">e</span> <span class="n">m</span>

<span class="k">let</span> <span class="n">term</span> <span class="o">=</span> <span class="k">let</span> <span class="k">open</span> <span class="nc">SYMSelf</span> <span class="k">in</span> <span class="n">succ</span> <span class="o">@@</span> <span class="n">succ</span> <span class="o">@@</span> <span class="n">zero</span>
</pre></div>
</div>
<p>What is the <code class="docutils literal notranslate"><span class="pre">term</span></code> in the last line?</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">module</span> <span class="nc">SYMShow</span> <span class="o">=</span> <span class="k">struct</span>
   <span class="k">type</span> <span class="n">repr</span> <span class="o">=</span> <span class="kt">string</span>
   <span class="k">let</span> <span class="n">zero</span> <span class="o">=</span> <span class="s2">&quot;0&quot;</span>
   <span class="k">let</span> <span class="n">succ</span> <span class="n">x</span> <span class="o">=</span> <span class="s2">&quot;succ(&quot;</span> <span class="o">^</span> <span class="n">x</span> <span class="o">^</span> <span class="s2">&quot;)&quot;</span>
<span class="k">end</span>

<span class="k">module</span> <span class="nc">SYMList</span> <span class="o">=</span> <span class="k">struct</span>
   <span class="k">type</span> <span class="n">repr</span> <span class="o">=</span> <span class="o">{</span><span class="n">f</span><span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span><span class="o">.</span> <span class="k">&#39;</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="n">a</span> <span class="kt">list</span><span class="o">}</span>
   <span class="k">let</span> <span class="n">zero</span> <span class="o">=</span> <span class="o">{</span><span class="n">f</span> <span class="o">=</span> <span class="k">fun</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="bp">[]</span><span class="o">}</span>
   <span class="k">let</span> <span class="n">succ</span> <span class="o">{</span><span class="n">f</span><span class="o">=</span><span class="n">x</span><span class="o">}</span> <span class="o">=</span> <span class="o">{</span><span class="n">f</span><span class="o">=</span><span class="k">fun</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">::</span><span class="n">x</span> <span class="n">a</span><span class="o">}</span>
<span class="k">end</span>

<span class="k">module</span> <span class="nc">SYMNat</span> <span class="o">=</span> <span class="k">struct</span>
   <span class="k">type</span> <span class="n">repr</span> <span class="o">=</span> <span class="kt">int</span>
   <span class="k">let</span> <span class="n">zero</span> <span class="o">=</span> <span class="mi">0</span>
   <span class="k">let</span> <span class="n">succ</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
<span class="k">end</span>

<span class="n">run</span> <span class="o">(</span><span class="k">module</span> <span class="nc">SYMShow</span><span class="o">)</span> <span class="n">term</span>
<span class="o">--</span> <span class="n">succ</span><span class="o">(</span><span class="n">succ</span><span class="o">(</span><span class="n">zero</span><span class="o">))</span>
<span class="k">let</span> <span class="o">(</span><span class="nn">SYMList</span><span class="p">.</span><span class="o">{</span><span class="n">f</span><span class="o">})</span> <span class="o">=</span> <span class="n">run</span> <span class="o">(</span><span class="k">module</span> <span class="nc">SYMList</span><span class="o">)</span> <span class="n">term</span> <span class="k">in</span> <span class="n">f</span> <span class="mi">1</span>
<span class="o">--</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span> <span class="mi">1</span><span class="o">]</span>
<span class="n">run</span> <span class="o">(</span><span class="k">module</span> <span class="nc">SYMList</span><span class="o">)</span> <span class="n">term</span>
<span class="o">--</span> <span class="mi">2</span>
</pre></div>
</div>
<p>This is neat!</p>
<p>Think that we implement each compiler phase, just like <code class="docutils literal notranslate"><span class="pre">SYMShow</span></code>, <code class="docutils literal notranslate"><span class="pre">SYMList</span></code>, <code class="docutils literal notranslate"><span class="pre">SYMNat</span></code>?</p>
</div>
<div class="section" id="grammar">
<h3>“Grammar”<a class="headerlink" href="#grammar" title="Permalink to this headline">¶</a></h3>
<p>Tagless Final firstly requires a grammar for the DSL, and it corresponds to our BNF gramamr.</p>
<p>We now give the structure of interpretion(incidentally, it’s called “grammar”) for aforementioned BNF grammar:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">type</span> <span class="n">litype</span> <span class="o">=</span> <span class="nc">IntT</span> <span class="o">|</span> <span class="nc">FloatT</span> <span class="o">|</span> <span class="nc">StringT</span>

<span class="k">module</span> <span class="k">type</span> <span class="nc">SYM</span> <span class="o">=</span> <span class="k">sig</span>
  <span class="k">type</span> <span class="n">repr</span>
  <span class="k">val</span> <span class="n">letl</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">repr</span> <span class="o">-&gt;</span> <span class="n">repr</span> <span class="o">-&gt;</span> <span class="n">repr</span>
  <span class="k">val</span> <span class="n">lam</span>  <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">repr</span> <span class="o">-&gt;</span> <span class="n">repr</span>
  <span class="k">val</span> <span class="n">app</span>  <span class="o">:</span> <span class="n">repr</span> <span class="o">-&gt;</span> <span class="n">repr</span> <span class="o">-&gt;</span> <span class="n">repr</span>
  <span class="k">val</span> <span class="n">lit</span>  <span class="o">:</span> <span class="n">litype</span> <span class="o">-&gt;</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">repr</span>
  <span class="k">val</span> <span class="n">var</span>  <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">repr</span>
<span class="k">end</span>
</pre></div>
</div>
<p>See the implementation of parser:</p>
<div class="highlight-antlr notranslate"><div class="highlight"><pre><span></span><span class="nl">expr</span><span class="p">:</span><span class="w"></span>
<span class="w">    </span><span class="no">LET</span><span class="w"> </span><span class="nv">n</span><span class="o">=</span><span class="no">ID</span><span class="w"> </span><span class="no">ASSIGN</span><span class="w"> </span><span class="nv">bound</span><span class="o">=</span><span class="nv">expr</span><span class="w"> </span><span class="no">IN</span><span class="w"> </span><span class="nv">body</span><span class="o">=</span><span class="nv">expr</span><span class="w"> </span><span class="p">{</span><span class="x">SYMSelf.letl n bound body</span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="no">FN</span><span class="w"> </span><span class="nv">n</span><span class="o">=</span><span class="no">ID</span><span class="w"> </span><span class="no">ARROW</span><span class="w"> </span><span class="nv">body</span><span class="o">=</span><span class="nv">expr</span><span class="w"> </span><span class="p">{</span><span class="x">SYMSelf.lam n body</span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
<span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>Then we got something that can be interpreted in various ways, instead of an AST!</p>
</div>
<div class="section" id="expanding-representation">
<h3>Expanding Representation<a class="headerlink" href="#expanding-representation" title="Permalink to this headline">¶</a></h3>
<p>The compiler phases are usually dependent.</p>
<p>Type inference requires name resolution, so how can we</p>
<ul class="simple">
<li>implement them separately, and</li>
<li>finally composite them
by using Tagless Final?</li>
</ul>
<p>Guess we have implemented these phases, for type infer and name resolution,
we shall have</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="c">(* name resolution *)</span>
<span class="k">module</span> <span class="nc">SYMScope</span> <span class="o">=</span> <span class="k">struct</span>
   <span class="k">type</span> <span class="n">repr</span> <span class="o">=</span> <span class="n">scope</span>
   <span class="o">..</span>
<span class="k">end</span>

<span class="c">(* type infer*)</span>
<span class="k">module</span> <span class="nc">SYMType</span> <span class="o">=</span> <span class="k">struct</span>
   <span class="k">type</span> <span class="n">repr</span> <span class="o">=</span> <span class="n">typ</span> <span class="c">(* your type representation *)</span>   
   <span class="k">let</span> <span class="n">letl</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">typ</span> <span class="o">-&gt;</span> <span class="n">typ</span> <span class="o">-&gt;</span> <span class="n">typ</span> <span class="o">=</span> <span class="o">..</span>
   <span class="o">..</span>
<span class="k">end</span>
</pre></div>
</div>
<p>Alas, we cannot use the information from <code class="docutils literal notranslate"><span class="pre">SYMScope</span></code> in <code class="docutils literal notranslate"><span class="pre">SYMType</span></code>!</p>
<p>So.. how could we address this problem?</p>
<p>Recall the order of phases,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mf">1.</span> <span class="n">name</span> <span class="n">resolution</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>     <span class="o">&lt;</span>
<span class="mf">2.</span> <span class="nb">type</span> <span class="n">infer</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>  <span class="o">&lt;</span>
<span class="mf">3.</span> <span class="n">closure</span> <span class="n">conversion</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>  <span class="o">&lt;</span>
<span class="mf">4.</span> <span class="n">elim</span> <span class="n">lambdas</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>        <span class="o">&lt;</span>
<span class="mf">5.</span> <span class="n">elim</span> <span class="n">name</span> <span class="n">shadowing</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>I guess, the <code class="docutils literal notranslate"><span class="pre">repr</span></code> is expanding bigger and bigger when passing the phases in order?</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="nb">repr</span> <span class="o">=</span> <span class="n">scope</span> <span class="o">-&gt;</span>
<span class="nb">type</span> <span class="nb">repr</span> <span class="o">=</span> <span class="n">scope</span> <span class="o">*</span> <span class="n">typ</span> <span class="o">-&gt;</span>
<span class="nb">type</span> <span class="nb">repr</span> <span class="o">=</span> <span class="n">scope</span> <span class="o">*</span> <span class="n">typ</span> <span class="o">*</span> <span class="n">closureinfo</span> <span class="o">-&gt;</span>
<span class="nb">type</span> <span class="nb">repr</span> <span class="o">=</span> <span class="n">scope</span> <span class="o">*</span> <span class="n">typ</span> <span class="o">*</span> <span class="n">closureinfo</span> <span class="o">*</span> <span class="n">lambdainfo</span> <span class="o">-&gt;</span>
<span class="nb">type</span> <span class="nb">repr</span> <span class="o">=</span> <span class="n">scope</span> <span class="o">*</span> <span class="n">typ</span> <span class="o">*</span> <span class="n">closureinfo</span> <span class="o">*</span> <span class="n">lambdainfo</span> <span class="o">*</span> <span class="n">unique_name</span> <span class="o">-&gt;</span>
<span class="o">...</span>
</pre></div>
</div>
</div>
<div class="section" id="problems-of-decoupling-and-compositing">
<h3>Problems of Decoupling and Compositing<a class="headerlink" href="#problems-of-decoupling-and-compositing" title="Permalink to this headline">¶</a></h3>
<p>However, if we implement a <code class="docutils literal notranslate"><span class="pre">SYM</span></code> with <code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">repr</span> <span class="pre">=</span> <span class="pre">scope</span> <span class="pre">*</span> <span class="pre">typ</span></code>,</p>
<ul class="simple">
<li><strong>Repetition, loss of decoupling</strong>: we have to repeat ourselves for writing code for <code class="docutils literal notranslate"><span class="pre">SYM</span> <span class="pre">with</span> <span class="pre">type</span> <span class="pre">repr</span> <span class="pre">=</span> <span class="pre">scope</span></code>. It seems impossible to reuse <code class="docutils literal notranslate"><span class="pre">SYM</span> <span class="pre">with</span> <span class="pre">type</span> <span class="pre">repr</span> <span class="pre">=</span> <span class="pre">scope</span></code> in <code class="docutils literal notranslate"><span class="pre">SYM</span> <span class="pre">with</span> <span class="pre">type</span> <span class="pre">repr</span> <span class="pre">=</span> <span class="pre">scope</span> <span class="pre">*</span> <span class="pre">typ</span></code>.</li>
<li><strong>Inflexibility, loss of compositing</strong>: and further, the most severe thing is, <strong>the order of phases gets fixed</strong>,
and if we misdesign the order of phases, we cannot compose things in a flexible style.</li>
</ul>
<p>To avoid above losses, just figure out a new abstraction on <code class="docutils literal notranslate"><span class="pre">SYM</span></code>, called <code class="docutils literal notranslate"><span class="pre">FSYM</span></code>.</p>
</div>
<div class="section" id="fsym">
<h3>FSYM<a class="headerlink" href="#fsym" title="Permalink to this headline">¶</a></h3>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">module</span> <span class="k">type</span> <span class="nc">FSYM</span> <span class="o">=</span> <span class="k">sig</span>
   <span class="k">type</span> <span class="n">o</span>
   <span class="k">type</span> <span class="n">c</span>
   <span class="k">type</span> <span class="n">r</span>
   <span class="k">val</span> <span class="n">combine</span> <span class="o">:</span> <span class="n">o</span> <span class="o">-&gt;</span> <span class="n">c</span> <span class="o">-&gt;</span> <span class="n">r</span>
   <span class="k">val</span> <span class="n">project</span> <span class="o">:</span> <span class="n">r</span> <span class="o">-&gt;</span> <span class="n">o</span>
   
   <span class="k">val</span> <span class="n">letl</span> <span class="o">:</span> <span class="n">o</span> <span class="o">-&gt;</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">r</span> <span class="o">-&gt;</span> <span class="n">r</span> <span class="o">-&gt;</span> <span class="n">c</span>
   <span class="k">val</span> <span class="n">lam</span>  <span class="o">:</span> <span class="n">o</span> <span class="o">-&gt;</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">r</span> <span class="o">-&gt;</span> <span class="n">c</span>
   <span class="k">val</span> <span class="n">app</span>  <span class="o">:</span> <span class="n">o</span> <span class="o">-&gt;</span> <span class="n">r</span> <span class="o">-&gt;</span> <span class="n">r</span> <span class="o">-&gt;</span> <span class="n">c</span>
   <span class="k">val</span> <span class="n">lit</span>  <span class="o">:</span> <span class="n">o</span> <span class="o">-&gt;</span> <span class="n">litype</span> <span class="o">-&gt;</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">c</span>
   <span class="k">val</span> <span class="n">var</span>  <span class="o">:</span> <span class="n">o</span> <span class="o">-&gt;</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">c</span>
<span class="k">end</span>

<span class="k">module</span> <span class="nc">Grow</span> <span class="o">(</span><span class="nc">Base</span><span class="o">:</span> <span class="nc">SYM</span><span class="o">)</span> <span class="o">(</span><span class="nc">Incr</span><span class="o">:</span> <span class="nc">FSYM</span> <span class="k">with</span> <span class="k">type</span> <span class="n">o</span> <span class="o">=</span> <span class="nn">Base</span><span class="p">.</span><span class="n">repr</span><span class="o">):</span> <span class="nc">SYM</span> <span class="k">with</span> <span class="k">type</span> <span class="n">repr</span> <span class="o">=</span> <span class="nn">Incr</span><span class="p">.</span><span class="n">r</span> <span class="o">=</span> <span class="k">struct</span>
  <span class="k">type</span> <span class="n">repr</span> <span class="o">=</span> <span class="nn">Incr</span><span class="p">.</span><span class="n">r</span>
  
  <span class="k">let</span> <span class="n">lam</span> <span class="n">n</span> <span class="n">r</span> <span class="o">=</span>
     <span class="k">let</span> <span class="n">o</span> <span class="o">=</span> <span class="nn">Base</span><span class="p">.</span><span class="n">lam</span> <span class="n">n</span> <span class="o">@@</span> <span class="nn">Incr</span><span class="p">.</span><span class="n">project</span> <span class="n">r</span> <span class="k">in</span>
     <span class="k">let</span> <span class="n">c</span> <span class="o">=</span> <span class="nn">Incr</span><span class="p">.</span><span class="n">lam</span> <span class="n">o</span> <span class="n">n</span> <span class="n">r</span> <span class="k">in</span>
     <span class="nn">Incr</span><span class="p">.</span><span class="n">combine</span> <span class="n">o</span> <span class="n">c</span>
  <span class="o">..</span>
<span class="k">end</span>
</pre></div>
</div>
<p>We can use <code class="docutils literal notranslate"><span class="pre">FSYM</span></code> to decouple and composite dependent compiler phases,
which is demonstrated in <a class="reference external" href="https://github.com/thautwarm/plfp/blob/master/view-point-from-research-side/Lamu0.md">Lamu0 by FSYM</a>.</p>
<p>Besides, the functor <code class="docutils literal notranslate"><span class="pre">Grow</span></code> also has a function form taking advantage of the first class modules:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">grow</span> <span class="o">=</span> <span class="k">fun</span>
   <span class="o">(</span><span class="k">type</span> <span class="n">o</span> <span class="n">c</span> <span class="n">r&#39;</span><span class="o">)</span>
   <span class="o">(</span><span class="k">module</span> <span class="nc">Base</span><span class="o">:</span> <span class="nc">SYM</span> <span class="k">with</span> <span class="k">type</span> <span class="n">r</span> <span class="o">=</span> <span class="n">o</span><span class="o">)</span>
   <span class="o">(</span><span class="k">module</span> <span class="nc">Incr</span><span class="o">:</span> <span class="nc">FSYM</span> <span class="k">with</span> <span class="k">type</span> <span class="n">r</span> <span class="o">=</span> <span class="n">r&#39;</span> <span class="ow">and</span> <span class="k">type</span> <span class="n">c</span> <span class="o">=</span> <span class="n">c</span> <span class="ow">and</span> <span class="k">type</span> <span class="n">o</span> <span class="o">=</span> <span class="n">o</span><span class="o">)</span> <span class="o">-&gt;</span>
  <span class="o">(</span><span class="k">module</span> <span class="k">struct</span>
   <span class="o">..</span>
   <span class="k">end</span><span class="o">:</span> <span class="nc">SYM</span> <span class="k">with</span> <span class="k">type</span> <span class="n">r</span> <span class="o">=</span> <span class="n">r&#39;</span><span class="o">)</span>
</pre></div>
</div>
</div>
<div class="section" id="laziness-for-mutual-dependencies">
<h3>Laziness, for Mutual Dependencies<a class="headerlink" href="#laziness-for-mutual-dependencies" title="Permalink to this headline">¶</a></h3>
<p>Given 2 compiler phases <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code>, there might be such a case:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">A</span></code> depends on a semi-complete <code class="docutils literal notranslate"><span class="pre">B</span></code>,</li>
<li>total-completion of <code class="docutils literal notranslate"><span class="pre">B</span></code> depends on a whole <code class="docutils literal notranslate"><span class="pre">A</span></code>, and</li>
<li><code class="docutils literal notranslate"><span class="pre">B</span></code>’s semi-completion can be done independently.</li>
</ul>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">module</span> <span class="nc">AB</span> <span class="o">=</span> <span class="nc">Grow</span><span class="o">(</span><span class="nc">A</span><span class="o">)(</span><span class="nc">B</span><span class="o">)</span>

<span class="c">(* including semi-completion of B *)</span>
<span class="k">let</span> <span class="o">(</span><span class="n">repr_a</span><span class="o">,</span> <span class="n">repr_b</span><span class="o">)</span> <span class="o">=</span> <span class="n">run</span> <span class="o">(</span><span class="k">module</span> <span class="nc">AB</span><span class="o">)</span> <span class="n">parsed_term</span>
</pre></div>
</div>
<p>Assume <code class="docutils literal notranslate"><span class="pre">repr_a</span></code> and <code class="docutils literal notranslate"><span class="pre">repr_b</span></code> are both lazy,
we can finish the semi-completion of <code class="docutils literal notranslate"><span class="pre">B</span></code> when calling <code class="docutils literal notranslate"><span class="pre">run</span></code>,
and then</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">repr_a</span> <span class="o">=</span> <span class="nn">Lazy</span><span class="p">.</span><span class="n">force</span> <span class="n">repr_a</span> <span class="c">(* total completion of A *)</span>
<span class="k">let</span> <span class="n">repr_b</span> <span class="o">=</span> <span class="nn">Lazy</span><span class="p">.</span><span class="n">force</span> <span class="n">repr_b</span> <span class="c">(* total completion of B *)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="example">
<h2>Example<a class="headerlink" href="#example" title="Permalink to this headline">¶</a></h2>
<p>A cleaner implementation of Tagless Final compiler is <a class="reference external" href="https://github.com/thautwarm/plfp/blob/master/lamu1"><code class="docutils literal notranslate"><span class="pre">Lamu1</span></code></a> instead of <code class="docutils literal notranslate"><span class="pre">Lamu0</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">Lamu1</span></code> extends <code class="docutils literal notranslate"><span class="pre">lamu0</span></code> with principal types.</p>
<p>You can try type inference of <code class="docutils literal notranslate"><span class="pre">Lamu1</span></code> in a REPL,
by following the simple guideline at <a class="reference external" href="https://github.com/thautwarm/plfp/blob/master/view-point-from-research-side/Lamu1.md#playground">here</a>.</p>
</div>
</div>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
<div id="sourcelink">
  <a href="../_sources/PL/plfp-20191219.md.txt"
     rel="nofollow">Source</a>
</div>
      
    </p>
    <p>
        &copy; Copyright 2020, thautwarm.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.0.<br/>
    </p>
  </div>
</footer>
  </body>
</html>